section "Example: Chat application"

theory example_chat
  imports 
    program_verification_tactics
    impl_language_loops
    crdt_specs2
    unique_ids
    program_proof_rules_loops
    app_verification_helpers
    unique_ids_loops
    proof_state_facts
begin


text_raw \<open>\DefineSnippet{chat_example_val}{\<close>
datatype val =
    String string
  | Bool bool
  | Undef
  | UserId int
  | ChatId int
  | MessageId int
  | Found val val
  | NotFound
text_raw \<open>}%EndSnippet\<close>


instance val :: countable
  by countable_datatype

fun uniqueIds_val_r  where 
  "uniqueIds_val_r (UserId i) = {}" \<comment> \<open>These are not considered Ids as they are not generated by this part of the app.\<close>
| "uniqueIds_val_r (MessageId i) = {to_nat i}"
| "uniqueIds_val_r (Found x y) = uniqueIds_val_r x \<union> uniqueIds_val_r y"
| "uniqueIds_val_r _ = {}"

instantiation val :: valueType begin
definition [simp]: "uniqueIds_val \<equiv> uniqueIds_val_r"
definition [simp]: "default_val \<equiv> Undef"

instance by (standard, auto)
end

instantiation val :: from_bool begin
definition [simp]: "from_bool_val \<equiv> Bool"

instance by (standard, auto)
end

fun stringval where
  "stringval (String s) = s"
| "stringval _ = ''''"


text_raw \<open>\DefineSnippet{chat_example_messageDataOp}{\<close>
datatype messageDataOp =
    Author "(val registerOp)"
  | Content "(val registerOp)"
text_raw \<open>}%EndSnippet\<close>



instance messageDataOp :: countable
  by countable_datatype
instantiation messageDataOp :: crdt_op begin
definition "uniqueIds_messageDataOp x \<equiv> 
  case x of 
     Author x \<Rightarrow> uniqueIds x
   | Content x \<Rightarrow> uniqueIds x"

lemma [simp]: "uniqueIds (Author x) = uniqueIds x"
  "uniqueIds (Content x) = uniqueIds x"
  by (auto simp add: uniqueIds_messageDataOp_def)

definition [simp]: "default_messageDataOp = Author default"

definition "is_update_messageDataOp x \<equiv> case x of Author x \<Rightarrow> is_update x | Content x \<Rightarrow> is_update x"

lemma is_update_messageDataOp_simp[simp]:
  "is_update (Author x) = is_update x"
  "is_update (Content y) = is_update y"
  by (auto simp add: is_update_messageDataOp_def)

instance by (standard, auto)
end

definition "isMessageId x \<equiv> case x of MessageId _ \<Rightarrow> True | _ \<Rightarrow> False"

text_raw \<open>\DefineSnippet{chat_example_operation}{\<close>
datatype operation =
    Chat "(val setOp)"
  | Message "((val, messageDataOp) mapOp)"
text_raw \<open>}%EndSnippet\<close>



instance operation :: countable
  by countable_datatype
instantiation operation :: crdt_op begin
definition "uniqueIds_operation x \<equiv> 
  case x of 
     Chat x \<Rightarrow> uniqueIds x
   | Message x \<Rightarrow> uniqueIds x"

lemma [simp]: "uniqueIds (Chat x) = uniqueIds x"
  "uniqueIds (Message y) = uniqueIds y"
  by (auto simp add: uniqueIds_operation_def)

definition [simp]: "default_operation = Chat default"

definition "is_update_operation x \<equiv> case x of Chat x \<Rightarrow> is_update x | Message x \<Rightarrow> is_update x"

instance by (standard, auto)
end

definition messageStruct :: "(messageDataOp, val) crdtSpec" where
  "messageStruct \<equiv> 
      struct_field Author (register_spec Undef)  
  .\<or>. struct_field Content (register_spec Undef) 
" 

definition crdtSpec :: "(operation, val) crdtSpec" where
"crdtSpec \<equiv> 
      struct_field Message (map_sdw_spec messageStruct) 
  .\<or>. struct_field Chat set_rw_spec 
"


definition messageStruct'  :: "('a, messageDataOp, val) ccrdtSpec"  where
  "messageStruct' \<equiv> 
       struct_field' Author (register_spec' Undef) 
  .\<or>.. struct_field' Content (register_spec' Undef) 
" 

definition crdtSpec' :: "(operation, operation, val) ccrdtSpec" where
"crdtSpec' \<equiv> 
        struct_field' Message (map_sdw_spec' messageStruct') 
  .\<or>.. struct_field'  Chat set_rw_spec' 
"

lemma subset_map_map:
  assumes "Cs \<subseteq> dom (map_map (calls ctxt) call_operation \<ggreater> C_in)"
  shows "Cs \<subseteq> dom (calls ctxt)"
  by (smt assms domI dom_map_map in_dom map_chain_eq_some subsetI)

lemma crdtSpec_rel:
  shows "crdt_spec_rel crdtSpec crdtSpec'"
  unfolding crdtSpec_def crdtSpec'_def
  by (auto simp add: inj_def messageStruct_def messageStruct'_def) 



lemma crdtSpec'_alt:
  assumes wf: "operationContext_wf ctxt" 
  shows "crdtSpec oper ctxt res
\<longleftrightarrow> crdtSpec' oper (dom (calls ctxt)) (extract_op (calls ctxt)) (happensBefore ctxt) id res "
  by (simp add: crdtSpec_rel local.wf operationContext_wf_hb_field use_crdt_spec_rel_toplevel)

lemma crdtSpec'_wf:
"ccrdtSpec_wf crdtSpec'"
  unfolding crdtSpec'_def
  by (auto simp add: messageStruct'_def  split: operation.splits )


lemma crdtSpec'_simp_op:
  assumes "Cs \<subseteq> vis"
  shows 
  "crdtSpec' oper Cs (extract_op (s_calls |` vis)) s_happensBefore id r
 = crdtSpec' oper Cs (extract_op (s_calls)) s_happensBefore id r"
  apply (rule use_ccrdtSpec_wf[OF crdtSpec'_wf])
  using assms by (auto simp add: map_same_on_def restrict_map_def extract_op_def split: option.splits call.splits)

lemma crdtSpec'_simp_hb:
  assumes "Cs \<subseteq> vis"
  shows "
   crdtSpec' oper Cs op (s_happensBefore |r vis) id r
 = crdtSpec' oper Cs op s_happensBefore id r"
apply (rule use_ccrdtSpec_wf[OF crdtSpec'_wf])
  using assms by (auto simp add: rel_same_on_def restrict_relation_def split: option.splits call.splits)



text_raw \<open>\DefineSnippet{sendMessage_impl}{\<close>
definition sendMessage_impl :: "val \<Rightarrow> val \<Rightarrow> (val,operation,val) io" where
  "sendMessage_impl from content \<equiv>  do {
  m \<leftarrow> newId isMessageId;
  atomic (do {
    call (Message (NestedOp m (Author (Assign from))));
    call (Message (NestedOp m (Content (Assign content))));
    call (Chat (Add m))
  });
  return m
}"
text_raw \<open>}%EndSnippet\<close>



text_raw \<open>\DefineSnippet{editMessage_impl}{\<close>
definition editMessage_impl :: "val \<Rightarrow> val \<Rightarrow> (val,operation,val) io" where
  "editMessage_impl m newContent \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then
      call (Message (NestedOp m (Content (Assign newContent))))
    else
      skip
  })
}"
text_raw \<open>}%EndSnippet\<close>


text_raw \<open>\DefineSnippet{deleteMessage_impl}{\<close>
definition deleteMessage_impl :: "val \<Rightarrow> (val,operation,val) io" where
  "deleteMessage_impl m \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then do {
      call (Chat (Remove m));
      call (Message (DeleteKey m))
    } else
      skip
  })
}"
text_raw \<open>}%EndSnippet\<close>
  

text_raw \<open>\DefineSnippet{getMessage_impl}{\<close>
definition getMessage_impl :: "val \<Rightarrow> (val,operation,val) io" where
  "getMessage_impl m \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then do {
      author \<leftarrow> call (Message (NestedOp m (Author Read)));
      content \<leftarrow> call (Message (NestedOp m (Content Read)));
      return (Found author content)
    } else do {
      return NotFound
    }
  })
}"
text_raw \<open>}%EndSnippet\<close>

 text \<open>
 \DefineSnippet{getMessage_impl2}{
    @{thm [display] getMessage_impl_def}
 }%EndSnippet
 \<close>




text_raw \<open>\DefineSnippet{chat_example_proc}{\<close>
datatype proc =
    SendMessage string string
  | EditMessage int string
  | DeleteMessage int
  | GetMessage int
text_raw \<open>}%EndSnippet\<close>


instance proc :: countable
  by countable_datatype

instantiation proc :: valueType begin
definition "uniqueIds_proc proc \<equiv> 
  case proc of 
     SendMessage a c \<Rightarrow> {}
   | EditMessage m s  \<Rightarrow> uniqueIds (MessageId m)
   | DeleteMessage m  \<Rightarrow> uniqueIds (MessageId m)
   | GetMessage m  \<Rightarrow> uniqueIds (MessageId m)"

lemma [simp]:
  "uniqueIds (SendMessage a c) = {}"
  "uniqueIds (EditMessage m s) = uniqueIds (MessageId m)"
  "uniqueIds (DeleteMessage m) = uniqueIds (MessageId m)"
  "uniqueIds (GetMessage m) = uniqueIds (MessageId m)"
  by (auto simp add: uniqueIds_proc_def)

definition [simp]: "default_proc \<equiv> SendMessage [] []"

instance by (standard, auto)
end

lemma inj_fields[simp]: "inj Chat"
  "inj Message"
  "inj Author"
  "inj Content"
  by (auto simp add: inj_def)

thm inj_fields

type_synonym localState = "val store  \<times> uniqueId set \<times> (val, operation, val) io"

text_raw \<open>\DefineSnippet{chat_example_procedures}{\<close>
definition procedures :: "proc \<Rightarrow> (localState \<times> (localState, operation, val) procedureImpl)" where
  "procedures invoc \<equiv>
  case invoc of
    SendMessage author content \<Rightarrow> toImpl' invoc (sendMessage_impl (String author) (String content))
  | EditMessage m newContent \<Rightarrow> toImpl' invoc (editMessage_impl (MessageId m) (String newContent))
  | DeleteMessage m \<Rightarrow>  toImpl' invoc (deleteMessage_impl (MessageId m))
  | GetMessage m  \<Rightarrow>  toImpl' invoc (getMessage_impl (MessageId m))
"
text_raw \<open>}%EndSnippet\<close>




(*
// getMessage returns correct authors
invariant (forall g: invocationId, m: MessageId, author: UserId, content: String ::
     g.info == getMessage(m)
  && g.result == getMessage_res(found(author, content))
  ==> (exists s: invocationId, content2: String :: s.info == sendMessage(author, content2)))
*)

definition inv1 where
"inv1 op res \<equiv> \<forall>g m author content.
    op g \<triangleq> GetMessage m
  \<and> res g \<triangleq> Found (String author) content
  \<longrightarrow> (\<exists>s content2. op s \<triangleq> SendMessage author content2)
"
    


(*
// additional invariants:
// for every author-assignment there is a corresponding invocation of sendMessage
invariant forall c: callId, m: MessageId, u: UserId ::
    c.op == message_author_assign(m, u)
    ==> (exists i: invocationId, s: String ::
            i.info == sendMessage(u, s))
*)

definition inv2 where
"inv2 op cop \<equiv> \<forall>c m u.
  cop c \<triangleq> Message (NestedOp m (Author (Assign (String u))))
  \<longrightarrow> (\<exists>i s. op i \<triangleq> SendMessage u s) "


(*
// if there is an assignment of the content field, there also is one for the author field that happened before:
invariant forall c1: callId, m: MessageId, s: String ::
    c1.op == message_content_assign(m, s)
    ==> (exists c2: callId, u: UserId ::
            c2.op == message_author_assign(m, u)
            && c2 happened before c1)
*)

definition inv3 where
"inv3 cop hb \<equiv> \<forall>c1 m s.
    cop c1 \<triangleq> Message (NestedOp m (Content (Assign s)))
    \<longrightarrow> (\<exists>c2 u. 
           cop c2 \<triangleq> Message (NestedOp m (Author (Assign u)))
           \<and> (c2, c1)\<in>hb) " 


(*
// there is no update after a delete
invariant !(exists write: callId, delete: callId, m: MessageId ::
       ((exists u: UserId ::  write.op == message_author_assign(m, u))
        || (exists s: String ::  write.op == message_content_assign(m, s)))
    && delete.op == message_delete(m)
    && delete happened before write)
*)


definition inv4 where
"inv4 cop hb \<equiv>
  \<nexists>write delete m no.
   cop write \<triangleq> Message (NestedOp m no)
   \<and> is_update no
   \<and> cop delete \<triangleq> Message (DeleteKey m)
   \<and> (delete,write)\<in>hb"

definition inv :: "(proc, operation, val) invContext \<Rightarrow> bool" where
  "inv ctxt \<equiv> 
    inv1 (invocOp ctxt) (invocRes ctxt) 
  \<and> inv2 (invocOp ctxt) (Op ctxt)
  \<and> inv3 (Op ctxt) (happensBefore ctxt)
  \<and> inv4 (Op ctxt) (happensBefore ctxt)"



text \<open>\DefineSnippet{chat_example_messageStruct_def}{
  @{thm [display] messageStruct_def}
}%EndSnippet\<close>

text \<open>\DefineSnippet{chat_example_crdtSpec_def}{
  @{thm [display] crdtSpec_def}
}%EndSnippet\<close>


text \<open>\DefineSnippet{chat_example_inv1}{
  @{thm [display] inv1_def}
}%EndSnippet\<close>

text \<open>\DefineSnippet{chat_example_inv2}{
  @{thm [display] inv2_def}
}%EndSnippet\<close>

text \<open>\DefineSnippet{chat_example_inv3}{
  @{thm [display] inv3_def}
}%EndSnippet\<close>

text \<open>\DefineSnippet{chat_example_inv4}{
  @{thm [display] inv4_def}
}%EndSnippet\<close>

text \<open>\DefineSnippet{chat_example_inv}{
  @{thm [display] inv_def}
}%EndSnippet\<close>


definition progr :: "(proc, localState, operation, val) prog" where
  "progr \<equiv> \<lparr>
  querySpec = crdtSpec,
  procedure = procedures,
  invariant = inv
\<rparr>"

lemma [simp]: "procedure progr = procedures"
"querySpec progr = crdtSpec"
"invariant progr = inv"
  by (auto simp add: progr_def)

declare convert_spec_def[simp]

(*
lemma uniqueId_no_nested: "x \<in> uniqueIds uid \<Longrightarrow> x = (to_nat (uid :: val))"
  by (auto simp add: uniqueIds_val_def split: val.splits)

lemma uniqueId_no_nested2: "x \<in> uniqueIds uid \<longleftrightarrow> (\<exists>u. x = to_nat (MessageId u) \<and> uid = MessageId u)"
  by (auto simp add: uniqueIds_val_def split: val.splits)
*)




lemma progr_wf[simp]: "program_wellFormed progr"
proof (auto simp add: program_wellFormed_def)
  show "invocations_cannot_guess_ids progr"
  proof (rule invocations_cannot_guess_ids_io)
    fix proc store localKnown cmd impl
    assume a0: "procedure progr proc = ((store, localKnown, cmd), impl)"

    thus "impl = impl_language_loops.toImpl \<and> localKnown = uniqueIds proc"
      by (auto simp add: progr_def procedures_def split: proc.splits)
  qed

  show "queries_cannot_guess_ids crdtSpec"
    by (auto simp add: inj_def crdtSpec_def messageStruct_def)
  
qed



lemma isMessageId_infinite[simp]: "infinite (Collect isMessageId)"
proof (rule infinite_if_mappable_to_nat)
  show "\<exists>x\<in>Collect isMessageId. n \<le> (case x of MessageId n \<Rightarrow> nat n)" for n
    by (rule bexI[where x="MessageId (int n)"],
        auto simp add: isMessageId_def)
qed







\<comment> \<open>Move to helpers\<close>
lemma get_query_spec2:
  assumes wf: "proof_state_wellFormed S"
    and upd_call: "calls S upd_c \<triangleq> Call oper upd_r"
  shows "\<exists>ctxt. querySpec (ps_prog S) oper ctxt upd_r"
proof -
  from wf
  obtain CS where rel: "proof_state_rel S CS"
    using proof_state_wellFormed_def by blast

  hence state_wf: "state_wellFormed CS"
    using proof_state_rel_wf by blast

  have upd_call': "calls CS upd_c \<triangleq> Call oper upd_r"
    using rel upd_call proof_state_rel_calls[OF rel] by auto

  have "prog CS = ps_prog S"
    using proof_state_rel_prog rel by fastforce

  from wf_queryspec[OF state_wf] upd_call' `prog CS = ps_prog S`
  obtain ctxt where "querySpec (ps_prog S) oper ctxt upd_r"
    apply atomize_elim
    apply auto
    by blast
  thus ?thesis
    by blast
qed

lemma select_field_some[simp]: 
  assumes "inj f"
  shows "select_field f (f x) \<triangleq> x"
  using assms by (auto simp add: select_field_def)

lemma select_field_none[simp]: 
  assumes "\<And>x y. g x \<noteq> f y"
  shows "select_field f (g x) = None"
  using assms by (auto simp add: select_field_def)


lemma query_result_undef:
  assumes wf: "proof_state_wellFormed S"
    and upd_call: "calls S upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
    and upd_is_update: "is_update upd_op"
    and progr: "ps_prog S = progr"
  shows "upd_r = Undef"
proof -

  obtain ctxt where "querySpec progr (Message (NestedOp (MessageId m) upd_op)) ctxt upd_r"
    using get_query_spec2 local.wf progr upd_call by fastforce


  thus "upd_r = Undef"
    using upd_is_update
    by (cases upd_op)
     (auto simp add: inj_def crdtSpec_def struct_field_def map_sdw_spec_def map_spec_def messageStruct_def register_spec_def split: messageDataOp.splits registerOp.splits if_splits)


qed



declare invContext.defs[simp]


lemmas crdt_spec_defs = 
  toplevel_spec_def crdtSpec'_def struct_field'_def map_sdw_spec'_def map_spec'_def messageStruct'_def register_spec'_def
  set_rw_spec'_def deleted_calls_sdw'_def

theorem chat_app_correct: "programCorrect progr"
proof M_show_programCorrect

  case invariant_initial_state
  show "invariant_all' (initialState progr)"
    by (simp add: inv_def initialState_def invContextH2_calls inv1_def inv2_def inv3_def inv4_def invContextH2_happensBefore invContextH2_i_invocOp progr_def)


  case (procedure_correct S i)



  show "procedureCorrect S i"
  proof (rule Initial_Label, rule show_initial_state_prop[OF procedure_correct], rule DC_final2, casify)
    case (show_P S_pre proc initState impl)
    have "invocOp S i \<triangleq> proc"
      using show_P by auto
    have "invocRes S i = None"
      using show_P apply auto
      using wf_result_after_invocation by blast

    have "uniqueIds proc \<subseteq> knownIds S"
      using show_P by auto


    note show_P[simp]

    show "procedureCorrect S i"
    proof (cases proc)
      case (SendMessage author content)

      show "procedureCorrect S i"
      proof M_show_procedureCorrect
        case after_invocation
         show ?case
           using show_P.invariant_pre SendMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
                metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound4)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: SendMessage procedures_def )

          show "localState S i \<triangleq> (Map.empty, uniqueIds (SendMessage author content), sendMessage_impl (String author) (String content))"
            by (auto simp add: SendMessage procedures_def )

          show "invocOp S i \<triangleq> SendMessage author content"
            using SendMessage \<open>invocOp S i \<triangleq> proc\<close> by blast

          note sendMessage_impl_def[simp]

          show "program_wellFormed (prog S)"
            by simp
            
          show "invariant_all' S"
            using execution.in_initial_state by blast

          show "crdt_spec_rel (querySpec progr) crdtSpec' "
            by (simp add: crdtSpec_rel)




          show "execution_s_check (invariant progr) crdtSpec' \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> SendMessage author content), invocRes = s_invocRes(i := None), ps_i = i, ps_generatedLocal = {}, ps_generatedLocalPrivate = {}, ps_localKnown = uniqueIds (SendMessage author content), ps_vis = {}, ps_localCalls = [], ps_tx = None, ps_firstTx = True, ps_store = Map.empty, ps_prog = progr\<rparr> (sendMessage_impl (String author) (String content)) (finalCheck (invariant progr) i)"
            if tx_fresh: "\<And>tx. s_txOrigin tx \<noteq> Some i"
              and inv_initial: "invariant progr \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> SendMessage author content), invocRes = s_invocRes(i := None)\<rparr>"
            for  s_calls s_happensBefore s_callOrigin s_txOrigin s_knownIds s_invocOp s_invocRes
          proof (repliss_vcg_l, fuzzy_goal_cases "AtCommit" "AtReturn" )
            case (AtCommit v vn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res ca resa cb resb PS')

            have [simp]: "res = Undef"
              using AtCommit.toplevel_spec
              by (auto simp add: crdt_spec_defs)
            have [simp]:"resa = Undef"
              using AtCommit.toplevel_spec2
              by (auto simp add: crdt_spec_defs)

            have [simp]:"resb = Undef"
              using AtCommit.toplevel_spec3
              by (auto simp add: crdt_spec_defs)

            have [simp]:  "in_sequence [c, ca, cb] c ca"
              by (simp add: in_sequence_cons)

            have "new_unique_not_in_calls s_calls' vn"
              by (meson AtCommit.uid_is_private'2 uid_is_private'_def)


            hence no_v: "vn \<notin> uniqueIds opr" if "cOp s_calls' c \<triangleq> opr" for c opr
              using that 
              by (auto simp add: new_unique_not_in_calls_def cOp_Some_iff)


            have [simp]: "cOp s_calls' delete \<noteq> Some (Message (DeleteKey v))" for delete
              apply auto
              apply (drule no_v)
             using `uniqueIds_val_r v = {vn}` by auto



            from AtCommit
            show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases  inv2 inv3 inv4)
              case (inv2)
              then show ?case
                by (auto simp add: inv2_def exists_cases1 )


            next
              case (inv3 )
              
              from inv3 show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong, meson)
            next
              case (inv4)


              then show ?case 
                by (auto simp add: inv4_def is_update_operation_def in_sequence_cons updateHb_cases)

            qed
              
              
          next
            case (AtReturn v tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res ca resa cb resb)
            from AtReturn.inv2
            show ?case
              apply (auto simp add: inv_def)
              apply (auto simp add: inv1_def)
              by (smt map_upd_Some_unfold proc.inject(1))
          qed
        qed
      qed

    next
      case (EditMessage m newContent)
      show "procedureCorrect S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre EditMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
              metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound4)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: EditMessage procedures_def )

          show "invocOp S i \<triangleq> EditMessage m newContent"
            using EditMessage \<open>invocOp S i \<triangleq> proc\<close> by blast


          show "localState S i \<triangleq> (Map.empty, uniqueIds (EditMessage m newContent), editMessage_impl (MessageId m) (String newContent))"
            by (auto simp add: EditMessage procedures_def )

          
          note editMessage_impl_def[simp]

          show "program_wellFormed (prog S)"
            by simp

          show "invariant_all' S"
            using execution.in_initial_state by blast

          show "crdt_spec_rel (querySpec progr) crdtSpec'"
            by (simp add: crdtSpec_rel)


          show "execution_s_check (invariant progr) crdtSpec' \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> EditMessage m newContent), invocRes = s_invocRes(i := None), ps_i = i, ps_generatedLocal = {}, ps_generatedLocalPrivate = {}, ps_localKnown = uniqueIds (EditMessage m newContent), ps_vis = {}, ps_localCalls = [], ps_tx = None, ps_firstTx = True, ps_store = Map.empty, ps_prog = progr\<rparr> (editMessage_impl (MessageId m) (String newContent)) (finalCheck (invariant progr) i)"
            if tx_fresh: "\<And>tx. s_txOrigin tx \<noteq> Some i"
              and inv_init: "invariant progr \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> EditMessage m newContent), invocRes = s_invocRes(i := None)\<rparr>"
            for  s_calls s_happensBefore s_callOrigin s_txOrigin s_knownIds s_invocOp s_invocRes
          proof (repliss_vcg_l, fuzzy_goal_cases "Exists_AtCommit" "Exists_AtReturn" "NotExists_AtCommit" "NotExists_AtReturn")
            
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa PS')

            note `c \<noteq> ca`[simp]

            from `example_chat.inv
             \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin', txOrigin = s_txOrigin',
                knownIds = s_knownIds', invocOp = s_invocOp'(i \<mapsto> EditMessage m newContent),
                invocRes = s_invocRes'(i := None)\<rparr>`
            have  i1: "inv1 (s_invocOp'(i \<mapsto> EditMessage m newContent)) (s_invocRes'(i := None))"
              and i2: "inv2 (s_invocOp'(i \<mapsto> EditMessage m newContent)) (cOp s_calls')"
              and i3: "inv3 (cOp s_calls') s_happensBefore'"
              and i4: "inv4 (cOp s_calls') s_happensBefore'"
              by (auto simp add: inv_def)

            from \<open>toplevel_spec crdtSpec' \<lparr>calls = s_calls', happensBefore = s_happensBefore'\<rparr> vis' (Message (KeyExists (MessageId m))) (Bool True)\<close>
            obtain upd_c upd_op upd_r
              where upd_vis: "upd_c \<in> vis'"
                and upd_call: "s_calls' upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
                and upd_is_update: "is_update upd_op"
                and ipd_not_deleted: "\<forall>c'. c' \<in> vis' \<longrightarrow> (\<forall>x2. s_calls' c' \<triangleq> x2 \<longrightarrow> (\<forall>x2a. x2 \<noteq> Call (Message (DeleteKey (MessageId m))) x2a) \<or> (c', upd_c) \<in> s_happensBefore')"
              using Exists_AtCommit.less_eq apply (auto simp add: crdt_spec_defs C_out_calls_def extract_op_def)
              by (metis (no_types, lifting) call.collapse call.sel(1) in_dom option.sel)



            have "upd_r = Undef"
              using Exists_AtCommit.proof_state_wellFormed
              by (rule query_result_undef[where upd_c=upd_c and upd_op=upd_op and m=m], use upd_call upd_is_update in auto)


            have "upd_c \<noteq> c"
              by (smt Exists_AtCommit(15) Exists_AtCommit(5) Exists_AtCommit(9) basic_trans_rules(31) domIff invContext.simps(1) operationContext.select_convs(1) upd_vis wellFormed_callOrigin_dom3)

            have "upd_c \<noteq> ca"
              by (smt Exists_AtCommit(15) Exists_AtCommit(5) Exists_AtCommit(9) basic_trans_rules(31) domIff invContext.simps(1) operationContext.select_convs(1) upd_vis wellFormed_callOrigin_dom)

            obtain upda_c upda_val
              where upda_call: "s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef"
                and upda_before_upd: "(upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c"
            proof (atomize_elim, cases upd_op)
              case (Author a)
              obtain x where "a = Assign x"
                using upd_is_update Author 
                by (cases a, auto simp add: is_update_messageDataOp_def)

              show "\<exists>upda_c upda_val.
                   s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                   ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                using Author \<open>a = Assign x\<close> upd_call \<open>upd_r = Undef\<close> by blast

            next
              case (Content a)
              obtain x where "a = Assign x"
                using upd_is_update Content 
                by (cases a, auto simp add: is_update_messageDataOp_def)

              show "\<exists>upda_c upda_val.
                 s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                 ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                using i3 Content \<open>a = Assign x\<close> \<open>upd_r = Undef\<close> upd_call
                apply (auto simp add: inv3_def cOp_Some_iff)
                using Exists_AtCommit.proof_state_wellFormed query_result_undef by fastforce
            qed



            have "upda_c \<noteq> c"
              using Exists_AtCommit \<open>upd_c \<noteq> c\<close> upda_before_upd by blast

            have "upda_c \<noteq> ca"
              using Exists_AtCommit \<open>upd_c \<noteq> ca\<close> upda_before_upd by blast





            from Exists_AtCommit
            show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases "inv2" "inv3" "inv4" )
              case (inv2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3)
              show ?case 
                apply (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong)
                 apply (rule exI[where x=upda_c])
                 apply (auto simp add: \<open>upda_c \<noteq> c\<close> \<open>upda_c \<noteq> ca\<close> upda_call)
                using causallyConsistent_def inv3.causallyConsistent upd_vis upda_before_upd apply force
                by (metis inv3.inv3 inv3.not_member2 inv3_def)
            next
              case (inv4)
              then show ?case 
                apply (auto simp add: inv4_def updateHb_cases in_sequence_cons)
                by (meson cOp_Some_iff ipd_not_deleted upd_call upd_is_update)
            qed
              
          next
            case (Exists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa)

            then show ?case 
              apply (auto simp add: inv_def )
              apply (auto simp add: inv1_def cong: conj_cong)
              by (smt map_upd_Some_unfold proc.distinct(1))
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res PS')
  
            then show ?case 
            proof (auto simp add: inv_def, fuzzy_goal_cases inv2 inv3 inv4)
              case (inv2 )
              then show ?case by (auto simp add: inv2_def)
            next
              case (inv3)
              then show ?case by (auto simp add: inv3_def updateHb_single cong: conj_cong, fastforce)
            next
              case (inv4)
              then show ?case 
                by (auto simp add: inv4_def updateHb_single)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res)
            then show ?case 
              apply (auto simp add: inv_def inv1_def cong: conj_cong)
              by (meson option.inject proc.simps(6))
          qed
        qed
      qed
    next
      case (DeleteMessage m)


      show "procedureCorrect S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre DeleteMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
              metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound4)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: DeleteMessage procedures_def )

          show "localState S i \<triangleq> (Map.empty, uniqueIds (DeleteMessage m), deleteMessage_impl (MessageId m))"
            by (auto simp add: DeleteMessage procedures_def )

          show "invocOp S i \<triangleq> DeleteMessage m"
            using DeleteMessage \<open>invocOp S i \<triangleq> proc\<close> by blast

          note deleteMessage_impl_def[simp]

          show "program_wellFormed (prog S)"
            by simp
            
          show "invariant_all' S"
            using execution.in_initial_state by blast

          show "crdt_spec_rel (querySpec progr) crdtSpec'"
            by (simp add: crdtSpec_rel)

          show "execution_s_check (invariant progr) crdtSpec' \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> DeleteMessage m), invocRes = s_invocRes(i := None), ps_i = i, ps_generatedLocal = {}, ps_generatedLocalPrivate = {}, ps_localKnown = uniqueIds (DeleteMessage m), ps_vis = {}, ps_localCalls = [], ps_tx = None, ps_firstTx = True, ps_store = Map.empty, ps_prog = progr\<rparr> (deleteMessage_impl (MessageId m)) (finalCheck (invariant progr) i)"
            if tx_fresh: "\<And>tx. s_txOrigin tx \<noteq> Some i"
              and inv_i: "invariant progr \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> DeleteMessage m), invocRes = s_invocRes(i := None)\<rparr>"
            for  s_calls s_happensBefore s_callOrigin s_txOrigin s_knownIds s_invocOp s_invocRes
          proof (repliss_vcg_l, fuzzy_goal_cases "Exists_AtCommit" "Exists_AtReturn" "NotExists_AtCommit" "NotExists_AtReturn")
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa cb res PS')

            have [simp]: "c \<noteq> ca" "c \<noteq> cb" "ca \<noteq> cb"
              by (simp add: Exists_AtCommit.not_c_eq Exists_AtCommit.not_c_eq2 Exists_AtCommit.not_ca_eq)+


            from `example_chat.inv
               \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin', txOrigin = s_txOrigin',
                  knownIds = s_knownIds', invocOp = s_invocOp'(i \<mapsto> DeleteMessage m), invocRes = s_invocRes'(i := None)\<rparr>`
            have  i1: "inv1 (s_invocOp'(i \<mapsto> DeleteMessage m)) (s_invocRes'(i := None))"
              and i2: "inv2 (s_invocOp'(i \<mapsto> DeleteMessage m)) (cOp s_calls')"
              and i3: "inv3 (cOp s_calls') s_happensBefore'"
              and i4: "inv4 (cOp s_calls') s_happensBefore'"
              by (auto simp add: inv_def)

            show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases inv1 inv2 inv3 inv4)
              case inv1
              from i1
              show ?case
                by (simp add: Exists_AtCommit.PS'_eq)
            next
              case inv2
              from i2
              show ?case
                by (auto simp add: inv2_def Exists_AtCommit.PS'_eq)
            next
              case inv3
              from i3
              show ?case 
                apply (auto simp add: inv3_def updateHb_cases Exists_AtCommit.PS'_eq cong: conj_cong)
                using Exists_AtCommit.not_member2 by blast

            next
              case inv4
              then show ?case
                using Exists_AtCommit.not_member2
                apply (auto simp add: inv4_def updateHb_cases in_sequence_cons Exists_AtCommit.PS'_eq)
                by (meson i4 inv4_def)
            qed
              
          next
            case (Exists_AtReturn)
            then show ?case
              apply (auto simp add: inv_def inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(3))
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res PS')
            then show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases inv2 inv3 inv4)
              case (inv2)
              then show ?case
                by (auto simp add: inv2_def)
            next
              case (inv3)
              then show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons, fastforce)

            next
              case (inv4)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cases in_sequence_cons)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res)
            then show ?case 
              apply (auto simp add: inv_def inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(3)) 
          qed
        qed
      qed
    next
      case (GetMessage m)


      show "procedureCorrect S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre GetMessage show_P.i_fresh
        proof (auto simp add:  inv_def invContextH2_simps, fuzzy_goal_cases inv1 inv2)
          case inv1
          then show ?case
            apply (auto simp add: inv1_def state_wellFormed_invocation_before_result)
            by (metis option.simps(3) show_P.i_fresh)
        next
          case inv2
          then show ?case
            apply (auto simp add: inv2_def)
            by (metis option.distinct(1) show_P.i_fresh)
        qed

      next
        case execution

        show "execution_s_correct S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound4)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: GetMessage procedures_def )

          show "localState S i \<triangleq> (Map.empty, uniqueIds (GetMessage m), getMessage_impl (MessageId m))"
            by (auto simp add: GetMessage procedures_def )

          show "invocOp S i \<triangleq> GetMessage m"
            using GetMessage \<open>invocOp S i \<triangleq> proc\<close> by blast

          note getMessage_impl_def[simp]

          show "program_wellFormed (prog S)"
            by simp

          show "invariant_all' S"
            using execution.in_initial_state by blast

          show "crdt_spec_rel (querySpec progr) crdtSpec'"
            by (simp add: crdtSpec_rel)

          show "execution_s_check (invariant progr) crdtSpec' \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> GetMessage m), invocRes = s_invocRes(i := None), ps_i = i, ps_generatedLocal = {}, ps_generatedLocalPrivate = {}, ps_localKnown = uniqueIds (GetMessage m), ps_vis = {}, ps_localCalls = [], ps_tx = None, ps_firstTx = True, ps_store = Map.empty, ps_prog = progr\<rparr> (getMessage_impl (MessageId m)) (finalCheck (invariant progr) i)"
            if tx_fresh: "\<And>tx. s_txOrigin tx \<noteq> Some i"
              and inv_pre: "invariant progr \<lparr>calls = s_calls, happensBefore = s_happensBefore, callOrigin = s_callOrigin, txOrigin = s_txOrigin, knownIds = s_knownIds, invocOp = s_invocOp(i \<mapsto> GetMessage m), invocRes = s_invocRes(i := None)\<rparr>"
            for  s_calls s_happensBefore s_callOrigin s_txOrigin s_knownIds s_invocOp s_invocRes
          proof (repliss_vcg_l, fuzzy_goal_cases "Exists_AtCommit" "Exists_AtReturn" uids1 uids2 "NotExists_AtCommit" "NotExists_AtReturn")
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa cb res PS')
            then show ?case 
            proof (auto simp add: inv_def, fuzzy_goal_cases inv2 inv3 inv4)
              case (inv2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3)
              then show ?case 
                by (auto simp add: inv3_def  updateHb_cons cong: conj_cong, meson)
            next
              case (inv4)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cons is_update_messageDataOp_def)
            qed  
          next
            case (Exists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa cb res)

            from \<open>example_chat.inv
             \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
                txOrigin = s_txOrigin', knownIds = s_knownIds',
                invocOp = s_invocOp'(i \<mapsto> GetMessage m), invocRes = s_invocRes'(i := None)\<rparr>\<close>
            have i1: "inv1 (s_invocOp'(i \<mapsto> GetMessage m)) (s_invocRes'(i := None))"
              and i2: "inv2 (s_invocOp'(i \<mapsto> GetMessage m)) (cOp s_calls')"
              and i3: "inv3 (cOp s_calls') s_happensBefore'"
              and i4: "inv4 (cOp s_calls') s_happensBefore'"
              by (auto simp add: inv_def)

            have "c \<notin> vis'"
              by (simp add: Exists_AtReturn.not_member)



            from Exists_AtReturn show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases inv1)
              case (inv1)



              show ?case
              proof (auto simp add: inv1_def cong: conj_cong)

                show "\<exists>s. s \<noteq> i \<and> (\<exists>content2. s_invocOp' s \<triangleq> SendMessage author content2)"
                  if c0: "g \<noteq> i"
                    and c1: "s_invocOp' g \<triangleq> GetMessage m'"
                    and c2: "s_invocRes' g \<triangleq> Found (String author) content"
                  for  g m' author content
                  using \<open>inv1 (s_invocOp'(i \<mapsto> GetMessage m)) (s_invocRes'(i := None))\<close>
                  using that apply (auto simp add: inv1_def)
                  by (metis option.inject proc.distinct(5))


                show "\<exists>s. s \<noteq> i \<and> (\<exists>content2. s_invocOp' s \<triangleq> SendMessage author content2)"
                  if c0: "resa = String author"
                  for  author
                proof -

                  have [simp]: "x \<in> Field (s_happensBefore' |r vis') \<Longrightarrow> x \<in> vis'" for x
                    by (auto simp add: Field_def restrict_relation_def)

                  hence [simp]: " x \<in> Field (s_happensBefore' |r vis') \<Longrightarrow> \<exists>y. s_calls' x \<triangleq> y" for x
                    by (meson  in_dom `vis' \<subseteq> dom s_calls'`)

                  from \<open>toplevel_spec crdtSpec' \<lparr>calls = s_calls', happensBefore = s_happensBefore'\<rparr> vis' (Message (KeyExists (MessageId m)))     (Bool True)\<close>
                  have "crdtSpec' (Message (KeyExists (MessageId m))) (dom s_calls' \<inter> vis') (extract_op s_calls') s_happensBefore' id (Bool True)"
                    by (simp add: inf_absorb2 inv1.less_eq toplevel_spec_def)



                  from this
                  obtain upd_c upd_call upd_op
                    where upd_call1: "s_calls' upd_c \<triangleq> upd_call"
                      and upd_vis: "upd_c \<in> vis'"
                      and upd_c_op: "extract_op s_calls' upd_c = Message (NestedOp (MessageId m) upd_op)"
                      and upd_is_update: "is_update upd_op"
                      and ud_not_deleted: "\<forall>d. extract_op s_calls' d = Message (DeleteKey (MessageId m)) \<longrightarrow> d \<in> dom s_calls' \<and> d \<in> vis' \<longrightarrow> (d, upd_c) \<in> s_happensBefore'"
                    by (auto simp add: C_out_calls_def crdtSpec'_def struct_field'_def map_sdw_spec'_def map_spec'_def deleted_calls_sdw'_def)

                  obtain upd_r where 
                    upd_call: "s_calls' upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
                    using upd_call1 upd_c_op
                    by (auto simp add: extract_op_def' split: call.splits)


                  have "upd_r = Undef"
                    using query_result_undef upd_call upd_is_update
                    using inv1.proof_state_wellFormed by auto 


                  obtain upda_c upda_val
                    where upda_call: "s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef"
                      and upda_before_upd: "(upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c"
                  proof (atomize_elim, cases upd_op)
                    case (Author a)
                    obtain x where "a = Assign x"
                      using upd_is_update Author 
                      by (cases a, auto simp add: is_update_messageDataOp_def)

                    show "\<exists>upda_c upda_val.
                   s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                   ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                      using Author \<open>a = Assign x\<close> upd_call \<open>upd_r = Undef\<close> by blast

                  next
                    case (Content a)
                    obtain x where "a = Assign x"
                      using upd_is_update Content 
                      by (cases a, auto simp add: is_update_messageDataOp_def)

                    show "\<exists>upda_c upda_val.
                 s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                 ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                      using i3 Content \<open>a = Assign x\<close> \<open>upd_r = Undef\<close> upd_call 
                      apply (auto simp add: inv3_def)
                      using cOp_Some_iff inv1.proof_state_wellFormed query_result_undef by fastforce
                  qed

                  have [simp]: "upda_c \<noteq> c"
                    using \<open>c \<notin> vis'\<close> inv1.not_member2 upd_vis upda_before_upd by blast

                  from \<open>toplevel_spec crdtSpec'
                       \<lparr>calls = s_calls'(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True)),
                          happensBefore = updateHb s_happensBefore' vis' [c]\<rparr>
                       (insert c vis') (Message (NestedOp (MessageId m) (Author Read))) resa\<close>
                  have spec0: "crdtSpec' (Message (NestedOp (MessageId m) (Author Read))) (insert c vis')     (extract_op (s_calls'(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True)))) (updateHb s_happensBefore' vis' [c]) id     resa"
                    by (simp add: toplevel_spec_def)
                  have [simp]: "(\<lambda>x. Message (NestedOp (MessageId m) x)) \<circ> Author
                      = Message \<circ> (NestedOp (MessageId m)) \<circ> Author"
                    by auto

                  have [simp]: "upda_c \<in> vis'"
                    using causallyConsistent_def inv1(6) upd_vis upda_before_upd by fastforce
                  have c_distinct[simp]: "c' \<noteq> c" if "c' \<in> vis'" for c'
                    using \<open>c \<notin> vis'\<close> that by blast

                  have c_in_dom[simp]: "c \<in> dom s_calls'" if "c \<in> vis'" for c
                    using inv1(4) that by blast

                  define ops' where "ops' \<equiv> extract_op (s_calls'(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True)))"
                  define hb' where "hb' \<equiv> updateHb s_happensBefore' vis' [c]"

                  from spec0
                  have "crdtSpec' (Message (NestedOp (MessageId m) (Author Read))) (insert c vis') ops' hb' id resa"
                    by (fold ops'_def hb'_def) auto

                  hence h1: "is_from resa Undef
                       (latest_values' (insert c vis' - deleted_calls_sdw' (insert c vis') ops' hb' Message (MessageId m)) ops' hb'
                         (Message \<circ> NestedOp (MessageId m) \<circ> Author))"
                    by (auto simp add: crdtSpec'_def map_sdw_spec'_def map_spec'_def messageStruct'_def register_spec'_def)


                  define author_vis where "author_vis \<equiv> insert c vis' -
                      deleted_calls_sdw' (insert c vis') ops' hb' Message (MessageId m)"


                  from h1
                  obtain updb_c 
                    where h2: "updb_c \<in> author_vis"
                      and h3: "ops' updb_c = Message (NestedOp (MessageId m) (Author (Assign (String author))))"
                      and h4: "\<forall>c'. c' \<in> author_vis \<longrightarrow>
                         (\<forall>v'. ops' c' \<noteq> Message (NestedOp (MessageId m) (Author (Assign v')))) \<or> (updb_c, c') \<notin> hb'"
                    apply (atomize_elim)
                    apply (auto simp add: c0 is_from_not_initial latest_values'_def)
                    apply (simp add: latest_assignments'_def)
                    subgoal for a
                      apply (rule exI[where x=a])
                      apply safe
                         apply (simp add: author_vis_def)
                      using author_vis_def apply blast+
                      done
                    done


                  have updb_c_call': "cOp s_calls' updb_c \<triangleq> Message (NestedOp (MessageId m) (Author (Assign (String author))))"
                    using h2 h3
                    apply (auto simp add: author_vis_def C_out_calls_def ops'_def extract_op_def restrict_calls_def split: if_splits)
                    by (metis (no_types, lifting) cOp_Some c_in_dom domIff option.exhaust_sel)

                  thm `inv2 (s_invocOp'(i \<mapsto> GetMessage m)) (cOp s_calls')`[unfolded inv2_def, rule_format, OF updb_c_call']
                  from `inv2 (s_invocOp'(i \<mapsto> GetMessage m)) (cOp s_calls')`[unfolded inv2_def, rule_format, OF updb_c_call']
                  obtain ia s where "(s_invocOp'(i \<mapsto> GetMessage m)) ia \<triangleq> SendMessage author s"
                    by blast


                  show "\<exists>s. s \<noteq> i \<and> (\<exists>content2. s_invocOp' s \<triangleq> SendMessage author content2)"
                    by (metis \<open>(s_invocOp'(i \<mapsto> GetMessage m)) ia \<triangleq> SendMessage author s\<close> map_upd_Some_unfold proc.simps(10))
                qed
              qed
            qed
          next
            case (uids1 tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa cb res)
            then show ?case
              by (auto simp add: inv_def)
          next
            case (uids2 tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c ca resa cb res)
            then show ?case
              by (auto simp add: inv_def)
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res)
            then show ?case
            proof (auto simp add: inv_def, fuzzy_goal_cases inv2 inv3 inv4)
              case (inv2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3)
              then show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong, fastforce)
            next
              case (inv4)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cases in_sequence_cons)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_txOrigin' s_knownIds' vis' s_invocOp' s_invocRes' c res)
            then show ?case
              apply (auto simp add: inv_def)
              apply (auto simp add: inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(5))
          qed
        qed
      qed
    qed
  qed
qed



end
