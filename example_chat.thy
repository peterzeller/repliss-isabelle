theory example_chat
  imports 
    program_verification_tactics
    impl_language
    crdt_specs2
    unique_ids
    program_proof_rules
begin


section "Example: Chat application"



datatype val =
    String string
  | UserId int
  | ChatId int
  | MessageId int
  | Bool bool
  | Undef
  | ListVal "val list"
  | Found val val
  | NotFound

instance val :: countable
  by countable_datatype

fun uniqueIds_val_r  where 
  "uniqueIds_val_r (UserId i) = {}" \<comment> \<open>These are not considered Ids as they are not generated by this part of the app.\<close>
| "uniqueIds_val_r (MessageId i) = {to_nat i}"
| "uniqueIds_val_r (ListVal vs) = \<Union>(set (map uniqueIds_val_r vs))"
| "uniqueIds_val_r (Found x y) = uniqueIds_val_r x \<union> uniqueIds_val_r y"
| "uniqueIds_val_r _ = {}"

instantiation val :: valueType begin
definition [simp]: "uniqueIds_val \<equiv> uniqueIds_val_r"
definition [simp]: "default_val \<equiv> Undef"

instance by (standard, auto)
end

fun stringval where
  "stringval (String s) = s"
| "stringval _ = ''''"


datatype messageDataOp =
    Author "val registerOp"
  | Content "val registerOp"


instance messageDataOp :: countable
  by countable_datatype
instantiation messageDataOp :: crdt_op begin
definition "uniqueIds_messageDataOp x \<equiv> 
  case x of 
     Author x \<Rightarrow> uniqueIds x
   | Content x \<Rightarrow> uniqueIds x"

lemma [simp]: "uniqueIds (Author x) = uniqueIds x"
  "uniqueIds (Content x) = uniqueIds x"
  by (auto simp add: uniqueIds_messageDataOp_def)

definition [simp]: "default_messageDataOp = Author default"

definition "is_update_messageDataOp x \<equiv> case x of Author x \<Rightarrow> is_update x | Content x \<Rightarrow> is_update x"

lemma is_update_messageDataOp_simp[simp]:
  "is_update (Author x) = is_update x"
  "is_update (Content y) = is_update y"
  by (auto simp add: is_update_messageDataOp_def)

instance by (standard, auto)
end

definition "isMessageId x \<equiv> case x of MessageId _ \<Rightarrow> True | _ \<Rightarrow> False"

datatype operation =
      Chat "val setOp"
    | Message "(val, messageDataOp) mapOp"


instance operation :: countable
  by countable_datatype
instantiation operation :: crdt_op begin
definition "uniqueIds_operation x \<equiv> 
  case x of 
     Chat x \<Rightarrow> uniqueIds x
   | Message x \<Rightarrow> uniqueIds x"

lemma [simp]: "uniqueIds (Chat x) = uniqueIds x"
  "uniqueIds (Message y) = uniqueIds y"
  by (auto simp add: uniqueIds_operation_def)

definition [simp]: "default_operation = Chat default"

definition "is_update_operation x \<equiv> case x of Chat x \<Rightarrow> is_update x | Message x \<Rightarrow> is_update x"

instance by (standard, auto)
end

definition messageStruct :: "(messageDataOp, val) crdtSpec" where
  "messageStruct \<equiv> (\<lambda>oper.
  case oper of
    Author op \<Rightarrow> struct_field (register_spec Undef op) (\<lambda>oper. case oper of Author op \<Rightarrow> Some op | _ \<Rightarrow> None) 
  | Content op \<Rightarrow> struct_field (register_spec Undef op) (\<lambda>oper. case oper of Content op \<Rightarrow> Some op | _ \<Rightarrow> None)
)" 

definition crdtSpec :: "(operation, val) crdtSpec" where
"crdtSpec \<equiv> (\<lambda>oper.
  case oper of
    Message op \<Rightarrow> struct_field (map_dw_spec Bool messageStruct op) (\<lambda>oper. case oper of Message op \<Rightarrow> Some op | _ \<Rightarrow> None) 
  | Chat op \<Rightarrow> struct_field (set_rw_spec Bool op) (\<lambda>oper. case oper of Chat op \<Rightarrow> Some op | _ \<Rightarrow> None)
)"


definition messageStruct'  :: "('a, messageDataOp, val) ccrdtSpec"  where
  "messageStruct' \<equiv> (\<lambda>oper.
  case oper of
    Author op \<Rightarrow> struct_field' Author (register_spec' Undef op) 
  | Content op \<Rightarrow> struct_field' Content (register_spec' Undef op) 
)" 

definition crdtSpec' :: "(operation, operation, val) ccrdtSpec" where
"crdtSpec' \<equiv> (\<lambda>oper.
  case oper of
    Message op \<Rightarrow> struct_field' Message (map_dw_spec' Bool messageStruct' op) 
  | Chat op \<Rightarrow> struct_field'  Chat (set_rw_spec' Bool op) 
)"

lemma crdtSpec'_alt:
  assumes hb_wf: "Field (happensBefore ctxt) \<subseteq> dom (calls ctxt)"
  shows "crdtSpec oper ctxt res
\<longleftrightarrow> crdtSpec' oper (dom (calls ctxt)) (extract_op (calls ctxt)) (happensBefore ctxt) id res "
proof (cases oper)
  case (Chat n_op)
  then show ?thesis
  proof (simp add: crdtSpec_def crdtSpec'_def)
    show "struct_field (set_rw_spec Bool n_op) (case_operation Some Map.empty) ctxt res 
      =  struct_field' Chat (set_rw_spec' Bool n_op) (dom (calls ctxt)) (extract_op (calls ctxt)) (happensBefore ctxt) id res"
    proof (fuzzy_rule struct_field_eq)
      show "sub_context Some (dom (calls ctxt)) ctxt = ctxt"
        using hb_wf sub_context_id2 by blast
      show "is_reverse Some id"
        by (simp add: is_reverse_trivial)
      show " is_reverse (\<lambda>a. case a of Chat x \<Rightarrow> Some x | Message x \<Rightarrow> Map.empty x) Chat"
        by (auto simp add: is_reverse_def split: operation.splits)

      show "dom (calls ctxt) \<subseteq> dom (calls ctxt)"
        by simp

      show "crdt_spec_rel (set_rw_spec Bool) (set_rw_spec' Bool)"
        by (rule set_rw_spec_rel)
    qed
  qed
next
  case (Message n_op)
  then show ?thesis
  proof (simp add: crdtSpec_def crdtSpec'_def)
    show "struct_field (map_dw_spec Bool messageStruct n_op) (case_operation Map.empty Some) ctxt res =
    struct_field' Message (map_dw_spec' Bool messageStruct' n_op) (dom (calls ctxt)) (extract_op (calls ctxt))
     (happensBefore ctxt) id res"
    proof (fuzzy_rule struct_field_eq)
      show "sub_context Some (dom (calls ctxt)) ctxt = ctxt"
        using hb_wf sub_context_id2 by blast
      show "is_reverse Some id"
        by (simp add: is_reverse_trivial)
      show "is_reverse (\<lambda>a. case a of Chat x \<Rightarrow> Map.empty x | Message x \<Rightarrow> Some x) Message"
        by (auto simp add: is_reverse_def split: operation.splits)
      show "dom (calls ctxt) \<subseteq> dom (calls ctxt)"
        by simp

      show "crdt_spec_rel (map_dw_spec Bool messageStruct) (map_dw_spec' Bool messageStruct')"
      proof (rule map_dw_spec_rel)
        show "crdt_spec_rel messageStruct messageStruct'"
        proof (simp add: crdt_spec_rel_def; intro allI impI)

          show "messageStruct op (sub_context C_in Cs ctxt) r = messageStruct' op Cs (extract_op (calls ctxt)) (happensBefore ctxt) C_out r"
            if c0: "is_reverse C_in C_out"
              and c1: "C_in outer_op \<triangleq> op"
              and c2: "Cs \<subseteq> dom (map_map (calls ctxt) call_operation \<ggreater> C_in)"
            for  C_in C_out ctxt outer_op op r Cs
          proof (cases op)
            case (Author author)
            show ?thesis
              unfolding messageStruct_def messageStruct'_def Author
            proof simp
              show "struct_field (register_spec Undef author) (case_messageDataOp Some Map.empty) (sub_context C_in Cs ctxt) r 
                 = struct_field' Author (register_spec' Undef author) Cs (extract_op (calls ctxt)) (happensBefore ctxt) C_out r"
              proof (fuzzy_rule struct_field_eq)

                show "is_reverse (case_messageDataOp Some Map.empty) Author"
                  by (auto simp add: is_reverse_def split: messageDataOp.splits)

                show "is_reverse C_in C_out"
                  by (simp add: c0)

                show "Cs \<subseteq> dom (calls ctxt)"
                  by (smt c2 domI in_dom map_chain_eq_some map_map_apply_eq_some subsetI)


                show "crdt_spec_rel (register_spec Undef) (register_spec' Undef)"
                  by (rule register_spec_rel)
              qed
            qed
          next
            case (Content content)
            show ?thesis
              unfolding messageStruct_def messageStruct'_def Content
            proof simp
              show "struct_field (register_spec Undef content) (case_messageDataOp Map.empty Some) (sub_context C_in Cs ctxt) r 
                 =  struct_field' Content (register_spec' Undef content) Cs (extract_op (calls ctxt)) (happensBefore ctxt) C_out r"
              proof (fuzzy_rule struct_field_eq)

                show "is_reverse (\<lambda>a. case a of Author x \<Rightarrow> Map.empty x | Content x \<Rightarrow> Some x) Content"
                  by (auto simp add: is_reverse_def split: messageDataOp.splits)

                show "is_reverse C_in C_out"
                  by (simp add: c0)

                show "Cs \<subseteq> dom (calls ctxt)"
                  by (smt c2 domI in_dom map_chain_eq_some map_map_apply_eq_some subsetI)

                show "crdt_spec_rel (register_spec Undef) (register_spec' Undef)"
                  by (rule register_spec_rel)
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed


lemma crdtSpec'_wf:
"ccrdtSpec_wf (crdtSpec' oper)"
  unfolding crdtSpec'_def
proof (auto  split: operation.splits)

  show "ccrdtSpec_wf (struct_field' Message (map_dw_spec' Bool messageStruct' x))"
    if c0: "oper = Message x"
    for  x
  proof (rule struct_field_wf)
    show "ccrdtSpec_wf (map_dw_spec' Bool messageStruct' x)"
    proof (rule map_dw_spec_wf)
      show "ccrdtSpec_wf (messageStruct' oper)" for oper
        unfolding messageStruct'_def by (auto split: messageDataOp.splits)
    qed
  qed
qed

lemma crdtSpec'_simp_op:
  assumes "Cs \<subseteq> vis"
  shows 
  "crdtSpec' oper Cs (extract_op (s_calls |` vis)) s_happensBefore id r
 = crdtSpec' oper Cs (extract_op (s_calls)) s_happensBefore id r"
  apply (rule use_ccrdtSpec_wf[OF crdtSpec'_wf])
  using assms by (auto simp add: map_same_on_def restrict_map_def extract_op_def split: option.splits call.splits)

lemma crdtSpec'_simp_hb:
  assumes "Cs \<subseteq> vis"
  shows "
   crdtSpec' oper Cs op (s_happensBefore |r vis) id r
 = crdtSpec' oper Cs op s_happensBefore id r"
apply (rule use_ccrdtSpec_wf[OF crdtSpec'_wf])
  using assms by (auto simp add: rel_same_on_def restrict_relation_def split: option.splits call.splits)




definition sendMessage_impl :: "val \<Rightarrow> val \<Rightarrow> (val,operation,val) io" where
  "sendMessage_impl from content \<equiv>  do {
  m \<leftarrow> newId isMessageId;
  atomic (do {
    call (Message (NestedOp m (Author (Assign from))));
    call (Message (NestedOp m (Content (Assign content))));
    call (Chat (Add m))
  });
  return m
}"


definition editMessage_impl :: "val \<Rightarrow> val \<Rightarrow> (val,operation,val) io" where
  "editMessage_impl m newContent \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then
      call (Message (NestedOp m (Content (Assign newContent))))
    else
      skip
  });
  return Undef
}"

definition deleteMessage_impl :: "val \<Rightarrow> (val,operation,val) io" where
  "deleteMessage_impl m \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then do {
      call (Chat (Remove m));
      call (Message (DeleteKey m))
    } else
      skip
  });
  return Undef
}"


definition getMessage_impl :: "val \<Rightarrow> (val,operation,val) io" where
  "getMessage_impl m \<equiv>  do {
  atomic (do {
    exists \<leftarrow> call (Message (KeyExists m));
    if exists = Bool True then do {
      author \<leftarrow> call (Message (NestedOp m (Author Read)));
      content \<leftarrow> call (Message (NestedOp m (Content Read)));
      return (Found author content)
    } else do {
      return NotFound
    }
  })
}"

datatype proc =
    SendMessage string string
  | EditMessage int string
  | DeleteMessage int
  | GetMessage int

instance proc :: countable
  by countable_datatype

instantiation proc :: valueType begin
definition "uniqueIds_proc proc \<equiv> 
  case proc of 
     SendMessage a c \<Rightarrow> {}
   | EditMessage m s  \<Rightarrow> uniqueIds (MessageId m)
   | DeleteMessage m  \<Rightarrow> uniqueIds (MessageId m)
   | GetMessage m  \<Rightarrow> uniqueIds (MessageId m)"

lemma [simp]:
  "uniqueIds (SendMessage a c) = {}"
  "uniqueIds (EditMessage m s) = uniqueIds (MessageId m)"
  "uniqueIds (DeleteMessage m) = uniqueIds (MessageId m)"
  "uniqueIds (GetMessage m) = uniqueIds (MessageId m)"
  by (auto simp add: uniqueIds_proc_def)

definition [simp]: "default_proc \<equiv> SendMessage [] []"

instance by (standard, auto)
end

abbreviation  toImpl2 where
 "toImpl2 (x :: (val,operation,val) io) \<equiv> (x , toImpl)"

definition procedures :: "proc \<Rightarrow> ((val, operation, val) io \<times> ((val, operation, val) io, operation, val) procedureImpl)" where
  "procedures invoc \<equiv>
  case invoc of
    SendMessage author content \<Rightarrow> toImpl2 (sendMessage_impl (String author) (String content))
  | EditMessage m newContent \<Rightarrow> toImpl2 (editMessage_impl (MessageId m) (String newContent))
  | DeleteMessage m \<Rightarrow>  toImpl2 (deleteMessage_impl (MessageId m))
  | GetMessage m  \<Rightarrow>  toImpl2 (getMessage_impl (MessageId m))
"



(*
// getMessage returns correct authors
invariant (forall g: invocationId, m: MessageId, author: UserId, content: String ::
     g.info == getMessage(m)
  && g.result == getMessage_res(found(author, content))
  ==> (exists s: invocationId, content2: String :: s.info == sendMessage(author, content2)))
*)

definition inv1 where
"inv1 op res \<equiv> \<forall>g m author content.
    op g \<triangleq> GetMessage m
  \<and> res g \<triangleq> Found (String author) content
  \<longrightarrow> (\<exists>s content2. op s \<triangleq> SendMessage author content2)
"
    


(*
// additional invariants:
// for every author-assignment there is a corresponding invocation of sendMessage
invariant forall c: callId, m: MessageId, u: UserId ::
    c.op == message_author_assign(m, u)
    ==> (exists i: invocationId, s: String ::
            i.info == sendMessage(u, s))
*)

definition inv2 where
"inv2 op cop \<equiv> \<forall>c m u.
  cop c \<triangleq> Call (Message (NestedOp m (Author (Assign (String u))))) Undef
  \<longrightarrow> (\<exists>i s. op i \<triangleq> SendMessage u s) "


(*
// if there is an assignment of the content field, there also is one for the author field that happened before:
invariant forall c1: callId, m: MessageId, s: String ::
    c1.op == message_content_assign(m, s)
    ==> (exists c2: callId, u: UserId ::
            c2.op == message_author_assign(m, u)
            && c2 happened before c1)
*)

definition inv3 where
"inv3 cop hb \<equiv> \<forall>c1 m s.
    cop c1 \<triangleq> Call (Message (NestedOp m (Content (Assign s)))) Undef
    \<longrightarrow> (\<exists>c2 u. 
           cop c2 \<triangleq> Call (Message (NestedOp m (Author (Assign u)))) Undef
           \<and> (c2, c1)\<in>hb) " 


(*
// there is no update after a delete
invariant !(exists write: callId, delete: callId, m: MessageId ::
       ((exists u: UserId ::  write.op == message_author_assign(m, u))
        || (exists s: String ::  write.op == message_content_assign(m, s)))
    && delete.op == message_delete(m)
    && delete happened before write)
*)


definition inv4 where
"inv4 cop hb \<equiv>
  \<nexists>write delete m no.
   cop write \<triangleq> Call (Message (NestedOp m no)) Undef
   \<and> is_update no
   \<and> cop delete \<triangleq> Call (Message (DeleteKey m)) Undef
   \<and> (delete,write)\<in>hb"

definition inv :: "(proc, operation, val) invariantContext \<Rightarrow> bool" where
  "inv ctxt \<equiv> 
    inv1 (invocationOp ctxt) (invocationRes ctxt) 
  \<and> inv2 (invocationOp ctxt) (calls ctxt)
  \<and> inv3 (calls ctxt) (happensBefore ctxt)
  \<and> inv4 (calls ctxt) (happensBefore ctxt)"


type_synonym localState = "(val,operation,val) io"

definition progr :: "(proc, localState, operation, val) prog" where
  "progr \<equiv> \<lparr>
  querySpec = crdtSpec,
  procedure = procedures,
  invariant = inv
\<rparr>"

lemma [simp]: "procedure progr = procedures"
"querySpec progr = crdtSpec"
"invariant progr = inv"
  by (auto simp add: progr_def)

declare convert_spec_def[simp]

(*
lemma uniqueId_no_nested: "x \<in> uniqueIds uid \<Longrightarrow> x = (to_nat (uid :: val))"
  by (auto simp add: uniqueIds_val_def split: val.splits)

lemma uniqueId_no_nested2: "x \<in> uniqueIds uid \<longleftrightarrow> (\<exists>u. x = to_nat (MessageId u) \<and> uid = MessageId u)"
  by (auto simp add: uniqueIds_val_def split: val.splits)
*)




lemma progr_wf[simp]: "program_wellFormed progr"
proof (auto simp add: program_wellFormed_def)
  show "procedures_cannot_guess_ids procedures"
  proof (auto simp add: procedures_cannot_guess_ids_def procedures_def uniqueIds_proc_def split: proc.splits)

    show "\<And>x11 x12 uids. procedure_cannot_guess_ids uids (sendMessage_impl (String x11) (String x12)) toImpl"
      by (auto simp add: sendMessage_impl_def, show_procedures_cannot_guess_ids  )

    show "\<And>x21 x22 uids. procedure_cannot_guess_ids (insert (to_nat x21) uids) (editMessage_impl (MessageId x21) (String x22)) toImpl"
     by (auto simp add: editMessage_impl_def, show_procedures_cannot_guess_ids  )

    show "\<And>x3 uids. procedure_cannot_guess_ids (insert (to_nat x3) uids) (deleteMessage_impl (MessageId x3)) toImpl"
      by (auto simp add: deleteMessage_impl_def, show_procedures_cannot_guess_ids  )

    show "\<And>x4 uids. procedure_cannot_guess_ids (insert (to_nat x4) uids) (getMessage_impl (MessageId x4)) toImpl "
      by (auto simp add: getMessage_impl_def, show_procedures_cannot_guess_ids  )
  qed

  show "queries_cannot_guess_ids crdtSpec"
  proof (auto simp add:  crdtSpec_def queries_cannot_guess_ids_def split: operation.splits)

    show "\<And>x1. query_cannot_guess_ids (uniqueIds x1) (struct_field (set_rw_spec Bool x1) (case_operation Some Map.empty))"
      by (standard, auto split: operation.splits)

    show "\<And>x2. query_cannot_guess_ids (uniqueIds x2) (struct_field (map_dw_spec Bool messageStruct x2) (case_operation Map.empty Some))"
    proof (standard, auto split: operation.splits)

      show "queries_cannot_guess_ids (map_dw_spec Bool messageStruct)"
      proof (standard, auto simp add: messageStruct_def queries_cannot_guess_ids_def split: messageDataOp.splits)

        show "\<And>x1. query_cannot_guess_ids (uniqueIds x1) (struct_field (register_spec Undef x1) (case_messageDataOp Some Map.empty))"
          by (standard, auto split: messageDataOp.splits)

        show "\<And>x2. query_cannot_guess_ids (uniqueIds x2) (struct_field (register_spec Undef x2) (case_messageDataOp Map.empty Some))"
          by (standard, auto split: messageDataOp.splits)
      qed
    qed
  qed
qed



lemma isMessageId_infinite[simp]: "infinite (Collect isMessageId)"
proof (rule infinite_if_mappable_to_nat)
  show "\<exists>x\<in>Collect isMessageId. n \<le> (case x of MessageId n \<Rightarrow> nat n)" for n
    by (rule bexI[where x="MessageId (int n)"],
        auto simp add: isMessageId_def)
qed

(* TODO utils *)
lemma ran_empty_iff[simp] :"(ran F = {}) \<longleftrightarrow> F = Map.empty"
  by (metis  empty_iff option.exhaust_sel ranI ran_empty)

lemma eq_map_empty[simp] :"(M = Map.empty) \<longleftrightarrow> (\<forall>x. M x = None)"
  by (rule fun_eq_iff)


(* TODO move to crdt_specs *)
lemma crdt_spec_wf_restrict_ctxt:
  assumes "crdt_spec_wf spec"
  shows "spec op (restrict_ctxt f ctxt) = spec op (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>)"
proof 
  fix r

  have h: "spec op ctxt r 
     = spec op (ctxt\<lparr>happensBefore := happensBefore ctxt |r dom (calls ctxt)\<rparr>) r" for ctxt
    using assms use_crdt_spec_wf
    by (metis restrict_hb_def) 
    
  have a: "spec op (restrict_ctxt f ctxt) r 
   = spec op ((restrict_ctxt f ctxt)\<lparr>happensBefore := happensBefore (restrict_ctxt f ctxt) |r dom (calls (restrict_ctxt f ctxt))\<rparr>) r "
    by (subst h, rule refl)



  have b: "spec op (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>) r
    = spec op ((ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>)\<lparr>happensBefore := happensBefore  (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>) |r dom (calls  (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>))\<rparr>) r "
    by (subst h, rule refl)

  have c: "((restrict_ctxt f ctxt)\<lparr>happensBefore := happensBefore (restrict_ctxt f ctxt) |r dom (calls (restrict_ctxt f ctxt))\<rparr>)
       =   ((ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>)\<lparr>happensBefore := happensBefore  (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>) |r dom (calls  (ctxt\<lparr>calls := fmap_map_values f (calls ctxt) \<rparr>))\<rparr>)"
    by (auto simp add: restrict_ctxt_def restrict_relation_def fmap_map_values_def intro!: operationContext.equality split: option.splits)   

  show "spec op (restrict_ctxt f ctxt) r = spec op (ctxt\<lparr>calls := fmap_map_values f (calls ctxt)\<rparr>) r"
    by (simp add: a b c)
qed


lemma "calls (restrict_ctxt_op x y) = ???"
  oops


(* TODO move *)
lemma use_some_wellFormed:
  assumes e: "\<exists>some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus.
       state_wellFormed
        \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
           transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
           invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
           generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
           visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
and R: "\<And>S. state_wellFormed S \<Longrightarrow> P S"
shows "\<exists>some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus. 
  P \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
           transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
           invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
           generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
           visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
proof -
  from e obtain some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus
    where "state_wellFormed
        \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
           transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
           invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
           generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
           visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
    by blast
  hence "P \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
           transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
           invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
           generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
           visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
    by (rule R)
  thus ?thesis
    by blast
qed

lemma get_query_spec:
  assumes wf: "\<exists>some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus.
     state_wellFormed
      \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
         transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
         invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
         generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
         visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
    and upd_call: "s_calls' upd_c \<triangleq> Call oper upd_r"
  shows "\<exists>ctxt. querySpec progr oper ctxt upd_r"
proof -
  from wf
  obtain some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus
    where state_wf: "state_wellFormed
                  \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
                     transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
                     invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
                     generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
                     visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
    by blast

  from wf_queryspec[OF state_wf] upd_call
  obtain ctxt where "querySpec progr oper ctxt upd_r"
    apply atomize_elim
    apply auto
    by blast
  thus ?thesis
    by blast
qed


lemma query_result_undef:
  assumes wf: "\<exists>some_generatedIds some_currentTransaction some_localState some_currentProc some_visibleCalls some_transactionStatus.
     state_wellFormed
      \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
         transactionOrigin = s_transactionOrigin', knownIds = s_knownIds', invocationOp = s_invocationOp',
         invocationRes = s_invocationRes', prog = progr, transactionStatus = some_transactionStatus,
         generatedIds = some_generatedIds, localState = some_localState, currentProc = some_currentProc,
         visibleCalls = some_visibleCalls, currentTransaction = some_currentTransaction\<rparr>"
    and upd_call: "s_calls' upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
    and upd_is_update: "is_update upd_op"
  shows "upd_r = Undef"
proof -

  obtain ctxt where "querySpec progr (Message (NestedOp (MessageId m) upd_op)) ctxt upd_r"
    using assms(1) get_query_spec upd_call by blast

  thus "upd_r = Undef"
    using upd_is_update
    by (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def messageStruct_def register_spec_def split: messageDataOp.splits registerOp.splits if_splits)

qed


lemma C_out_calls_remove_unaffected:
  assumes "\<And>y. C_out y \<noteq> x"
  shows "C_out_calls C_out (m(c := x)) vis
  = C_out_calls C_out m vis - {c}"
  using assms  by (auto simp add: C_out_calls_def)

lemma C_out_nesting_simp:
  assumes "C_out1 = C_out2 \<circ> f"
  shows
  "C_out_calls C_out1 op (C_out_calls C_out2 op vis)
= C_out_calls C_out1 op vis" 
  by (auto simp add: assms C_out_calls_def)

lemma C_out_nesting_simp2[simp]:
  shows
  "C_out_calls (C_out \<circ> f) op (C_out_calls C_out op vis)
= C_out_calls (C_out \<circ> f) op vis" 
  by (auto simp add:  C_out_calls_def)

lemma C_out_calls_empty[simp]: "C_out_calls C_out op {} = {}"
  by (auto simp add: C_out_calls_def)

lemma C_out_union: 
"C_out_calls C_out op (A \<union> B) = C_out_calls C_out op A \<union> C_out_calls C_out op B"
  by (auto simp add: C_out_calls_def)

lemma C_out_insert: 
"C_out_calls C_out op (insert c A) = (if \<exists>x. op c = C_out x then {c} else {}) \<union> C_out_calls C_out op A"
  by (auto simp add: C_out_calls_def)

lemma C_out_intersection: 
"C_out_calls C_out op (A \<inter> B) = C_out_calls C_out op A \<inter> C_out_calls C_out op B"
  by (auto simp add: C_out_calls_def)

lemma C_out_minus: 
"C_out_calls C_out op (A - B) = C_out_calls C_out op A - C_out_calls C_out op B"
  by (auto simp add: C_out_calls_def)

lemma in_C_out:
"x \<in> C_out_calls C_out op vis
\<longleftrightarrow> x\<in> vis \<and> (\<exists>y. op x = C_out y)"
  by (auto simp add: C_out_calls_def)

lemmas C_out_distrib = C_out_union  C_out_insert C_out_intersection C_out_minus

(* TODO utils *)
definition is_path
  where "is_path path r \<equiv> (\<forall>i<length path - 1. (path!i, path!(Suc i))\<in>r)"

lemma is_path_empty[simp]:
  shows "is_path [] r"
  by (auto simp add: is_path_def)

lemma is_path_single[simp]:
  shows "is_path [x] r"
  by (auto simp add: is_path_def)

lemma is_path_cons:
  shows "is_path (x#y#xs) r \<longleftrightarrow> (x,y)\<in>r \<and> is_path (y#xs) r"
  using less_Suc_eq_0_disj by (auto simp add: is_path_def)

lemma is_path_cons2:
  shows "is_path (x#xs) r \<longleftrightarrow> (xs = [] \<or> (x,hd xs)\<in>r \<and> is_path xs r)"
  by (metis is_path_cons is_path_single list.collapse)



lemma is_path_append:
  assumes "xs \<noteq> []" and "ys \<noteq> []"
  shows
"is_path (xs@ys) r \<longleftrightarrow> is_path xs r \<and> (last xs, hd ys)\<in>r \<and> is_path ys r"
  using assms by (induct xs, auto simp add: is_path_cons2)




lemma is_path_trans_cl:
  shows "(x,y)\<in>r\<^sup>+ \<longleftrightarrow> (\<exists>path. length path > 1 \<and> is_path path r \<and> hd path = x \<and> last path = y)"
proof
  show "\<exists>path. 1 < length path \<and> is_path path r \<and> hd path = x \<and> last path = y" if "(x, y) \<in> r\<^sup>+"
    using that
  proof (induct)
    case (base y)
    show ?case 
    proof (intro conjI exI)
      show "hd [x,y] = x" by simp
      show "last [x, y] = y" by simp
      show "1 < length [x, y]" by simp
      show "is_path [x, y] r" by (auto simp add: is_path_def base)
    qed
  next
    case (step y z)
    from this
    obtain path 
      where "1 < length path"
        and "is_path path r"
        and "hd path = x"
        and "last path = y"
      by blast

    have "path \<noteq> []"
      using \<open>1 < length path\<close> by auto


    show ?case
    proof (intro conjI exI)
      show "hd (path @ [z]) = x" using `hd path = x` `path \<noteq> []` by simp
      show "1 < length (path @ [z])"  using \<open>1 < length path\<close> by auto 
      show "is_path (path @ [z]) r" using `is_path path r` `(y, z) \<in> r` apply (auto simp add: is_path_def nth_append)
        by (metis Suc_lessI \<open>last path = y\<close> \<open>path \<noteq> []\<close> diff_Suc_1 last_conv_nth)

      show "last (path @ [z]) = z" by simp
    qed
  qed

next
  assume "\<exists>path. 1 < length path \<and> is_path path r \<and> hd path = x \<and> last path = y"
  from this obtain path
    where "1 < length path"
      and "is_path path r"
      and "hd path = x"
      and "last path = y"
    by blast

  thus "(x, y) \<in> r\<^sup>+"
  proof (induct path arbitrary: x y rule: rev_induct)
    case Nil
    then show ?case by simp
  next
    case (snoc e path x y)
    show ?case
    proof (cases "1 < length path")
      case True
      have "(x, last path) \<in> r\<^sup>+"
        using `1 < length path`
      proof (rule snoc.hyps)
        show "is_path path r"
          by (metis True is_path_append less_numeral_extra(2) list.size(3) not_Cons_self2 snoc.prems(2))
        show "hd path = x"
          using True dual_order.strict_trans snoc.prems(3) by fastforce
        show "last path = last path" ..
      qed

      from `is_path (path @ [e]) r`
      have "(last path, e) \<in> r"
        by (metis One_nat_def True is_path_append length_greater_0_conv list.sel(1) not_Cons_self2 order.strict_trans zero_less_Suc)


      show "(x, y) \<in> r\<^sup>+"
        using \<open>(last path, e) \<in> r\<close> \<open>(x, last path) \<in> r\<^sup>+\<close> `last (path @ [e]) = y` by auto
    next
      assume "\<not> 1 < length path"
      hence "length path \<le> 1" by simp
      hence "length path = 1"
        using less_Suc_eq snoc.prems(1) by auto

      hence "(x,y)\<in>r"
        by (metis One_nat_def append_is_Nil_conv diff_Suc_1 hd_conv_nth is_path_def last_snoc length_append_singleton less_Suc_eq not_Cons_self nth_append_length snoc.prems(2) snoc.prems(3) snoc.prems(4))


      thus "(x, y) \<in> r\<^sup>+"
        by simp
    qed
  qed
qed



lemma acyclic_path:
"acyclic r \<longleftrightarrow> (\<nexists>path. length path > 1 \<and> is_path path r \<and> hd path = last path)"
  by (auto simp add: acyclic_def is_path_trans_cl)



lemma acyclic_union_disjoint:
  assumes "acyclic r"
    and "acyclic s"
    and "snd ` s \<inter> fst ` r = {}"
  shows "acyclic (r \<union> s)"
proof (auto simp add:  acyclic_path)
  fix path
  assume a0: "is_path path (r \<union> s)"
    and a1: "Suc 0 < length path"
    and a2: "hd path = last path"

 

  have all_following_in_s: 
    "(path!j, path!Suc j)\<in>s"
    if "(path!i, path!Suc i)\<in>s"
      and "j\<ge>i" 
      and "j < length path - 1"
      and "i < length path - 1"
    for i j
    using that
  proof (induct "j-i" arbitrary: j)
    case 0
    then show ?case 
      using `(path!i, path!Suc i)\<in>s`
      by auto
  next
    case (Suc n)
    have [simp]: "Suc (j - 1) = j"
      using Suc.hyps(2) by auto

    have [simp]: "Suc (j - Suc 0) = j"
      using Suc.hyps(2) by auto

    have "(path ! (j - 1), path ! Suc (j - 1)) \<in> s" 
    proof (rule Suc.hyps)
      show "n = j - 1 - i"
        using Suc.hyps(2) by auto
      show "i \<le> j - 1"
        using Suc.hyps(2) by linarith
      show "j - 1 < length path - 1"
        using Suc.prems less_imp_diff_less by blast
      show " i < length path - 1"
        using that by blast
      show " (path ! i, path ! Suc i) \<in> s"
        by (simp add: that)
    qed
    hence "path ! j \<in> snd ` s"
      by (simp add: rev_image_eqI)


    have "(path ! j, path ! Suc j) \<notin> r"
    proof (rule ccontr, simp)
      assume "(path ! j, path ! Suc j) \<in> r"
      hence "path ! j \<in> fst ` r"
        using image_iff by fastforce

      with \<open>snd ` s \<inter> fst ` r = {}\<close> \<open>path ! j \<in> snd ` s\<close>
      show False  by auto
    qed


    thus "(path ! j, path ! Suc j) \<in> s"
      by (meson Suc.prems Un_iff a0 is_path_def)
  qed

  have "(path!0, path!1)\<in>r"
  proof (rule ccontr)
    assume "(path ! 0, path ! 1) \<notin> r "
    hence "(path ! 0, path ! 1) \<in> s"
      by (metis One_nat_def Un_iff a0 a1 is_path_def zero_less_diff)
    have "is_path path s"
      apply (auto simp add: is_path_def)
      by (metis One_nat_def \<open>(path ! 0, path ! 1) \<in> s\<close> a1 all_following_in_s less_Suc0 not_le_imp_less not_less_iff_gr_or_eq zero_less_diff)
    thus False
      using `acyclic s`
      by (metis One_nat_def a1 a2 acyclic_path)
  qed


  obtain i 
    where "i < length path - 1"
      and "(path!i, path!Suc i)\<notin>r"
    apply (atomize_elim, rule ccontr)
    using `acyclic r` apply (auto simp add: acyclic_path)
    by (metis One_nat_def a1 a2 is_path_def)

  hence "(path!i, path!Suc i)\<in>s"
    by (meson Un_iff a0 is_path_def)

  hence "(path!(length path - 2),path!(Suc ((length path - 2))))\<in>s" 
  proof (rule all_following_in_s)
    show " i \<le> length path - 2"
      using \<open>i < length path - 1\<close> by linarith
    show "length path - 2 < length path - 1"
      by (simp add: a1 diff_less_mono2)
    show "i < length path - 1"
      using \<open>i < length path - 1\<close> by blast
  qed

  have "hd path \<in> fst ` r"
    by (metis One_nat_def \<open>(path ! 0, path ! 1) \<in> r\<close> a1 fst_conv hd_conv_nth image_iff list.size(3) not_one_less_zero)

  have "last path \<in> snd ` s"
    by (metis One_nat_def Suc_diff_Suc \<open>(path ! (length path - 2), path ! Suc (length path - 2)) \<in> s\<close> a1 image_iff last_conv_nth list.size(3) not_one_less_zero numeral_2_eq_2 snd_conv)


  from `hd path = last path` \<open>snd ` s \<inter> fst ` r = {}\<close>
  show "False"
    using \<open>hd path \<in> fst ` r\<close> \<open>last path \<in> snd ` s\<close>  by auto
qed

lemma acyclic_empty[simp]: "acyclic {}"
  by (simp add: wf_acyclic)

lemma acyclic_prod: "acyclic (A \<times> B) \<longleftrightarrow> A \<inter> B = {}"
  apply (auto simp add: acyclic_def)
  by (metis (no_types, lifting) SigmaD1 SigmaD2 disjoint_iff_not_equal tranclE)


lemma acyclic_updateHb1:
  assumes "distinct cs"
    and "vis \<inter> set cs = {}"
  shows "acyclic (updateHb {} vis cs)"
  using assms proof (induct cs arbitrary: vis)
  case Nil
  then show ?case by auto
next
  case (Cons a cs vis)
  have "a \<notin> vis"
    using Cons.prems(2) by auto


  show ?case 
    apply (simp add: updateHb_cons)
    apply (subst updateHb_simp_split)
  proof (rule acyclic_union_disjoint)
    show "acyclic (vis \<times> {a})"
      by (simp add: acyclic_prod `a \<notin> vis`)
    show " acyclic (updateHb {} (insert a vis) cs)"
    proof (rule Cons.hyps)
      show "distinct cs"
        using Cons.prems(1) by auto
      show "insert a vis \<inter> set cs = {}"
        using Cons.prems(1) Cons.prems(2) by auto
    qed

    show " snd ` updateHb {} (insert a vis) cs \<inter> fst ` (vis \<times> {a}) = {}"
      using Cons.prems(2) snd_updateHb2 by fastforce
  qed
qed

lemma acyclic_updateHb:
  assumes "acyclic hb"
    and "distinct cs"
    and "vis \<inter> set cs = {}"
    and "Field hb \<inter> set cs = {}"
  shows "acyclic (updateHb hb vis cs)"
  apply (subst  updateHb_simp_split)
  using `acyclic hb`
proof (rule acyclic_union_disjoint)

  show "acyclic (updateHb {} vis cs)"
    by (simp add: acyclic_updateHb1 assms(2) assms(3))

  show "snd ` updateHb {} vis cs \<inter> fst ` hb = {}"
    by (smt Domain_fst Field_def Int_iff assms(4) disjoint_iff_not_equal inf_sup_absorb snd_updateHb2 subset_eq)
qed

  


theorem chat_app_correct: "programCorrect progr"
proof M_show_programCorrect

  case invariant_initial_state
  show "invariant_all' (initialState progr)"
    by (simp add: inv_def initialState_def invContextH2_calls inv1_def inv2_def inv3_def inv4_def invContextH2_happensBefore invContextH2_i_invocationOp progr_def)


  case (procedure_correct S i)



  show "procedureCorrect progr S i"
  proof (rule Initial_Label, rule show_initial_state_prop[OF procedure_correct], rule DC_final2, casify)
    case (show_P S_pre proc initState impl)
    have "invocationOp S i \<triangleq> proc"
      using show_P by auto
    have "invocationRes S i = None"
      using show_P apply auto
      using state_wellFormed_invocation_before_result by blast

    have "uniqueIds proc \<subseteq> knownIds S"
      using show_P by auto


    note show_P[simp]

    show "procedureCorrect progr S i"
    proof (cases proc)
      case (SendMessage author content)

      show "procedureCorrect progr S i"
      proof M_show_procedureCorrect
        case after_invocation
         show ?case
           using show_P.invariant_pre SendMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
                metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct progr S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound3)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: SendMessage procedures_def )

          show "localState S i \<triangleq> sendMessage_impl (String author) (String content)"
            by (auto simp add: SendMessage procedures_def )

          show "invocationOp S i \<triangleq> SendMessage author content"
            using SendMessage \<open>invocationOp S i \<triangleq> proc\<close> by blast

          note sendMessage_impl_def[simp]


          show "execution_s_check progr i s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds (s_invocationOp(i \<mapsto> SendMessage author content)) (s_invocationRes(i := None)) {} {} {} [] None True (sendMessage_impl (String author) (String content))"
            if tx_fresh: "(\<And>tx. s_transactionOrigin tx \<noteq> Some i)"
            for  s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds s_invocationOp s_invocationRes
          proof (repliss_vcg, goal_cases "AtCommit" "AtReturn" )
            case (AtCommit v tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)

            have [simp]: "res = Undef"
              using local.AtCommit(16)
              by (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def messageStruct_def register_spec_def)
            have [simp]:"resa = Undef"
              using local.AtCommit(17)
              by (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def messageStruct_def register_spec_def)

            have [simp]:"resb = Undef"
              using local.AtCommit(18)
              by (auto simp add: crdtSpec_def struct_field_def set_rw_spec_def)

            have [simp]:  "in_sequence [c, ca, cb] c ca"
              by (simp add: in_sequence_cons)

            have "new_unique_not_in_calls s_calls' (to_nat v)"
              by (meson AtCommit(13) uid_is_private'_def)


            hence no_v: "to_nat v \<notin> uniqueIds opr" if "s_calls' c \<triangleq> Call opr r" for c opr r
              by (meson new_unique_not_in_calls_def that)

            have [simp]: "s_calls' delete \<noteq> Some (Call (Message (DeleteKey v)) Undef)" for delete
              apply auto
              apply (drule no_v)
             using `uniqueIds_val_r v = {to_nat v}` by auto

            from AtCommit
            show ?case
            proof (auto simp add: inv_def, goal_cases  inv2 inv3 inv4)
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case
                by (auto simp add: inv2_def exists_cases1)

            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              
              from inv3 show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong, meson)
            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv4_def is_update_operation_def in_sequence_cons updateHb_cases)
            qed
              
              
          next
            case (AtReturn v tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)
            then show ?case
              apply (auto simp add: inv_def)
              apply (auto simp add: inv1_def)
              by (smt map_upd_Some_unfold proc.inject(1))

          qed

        qed
      qed

    next
      case (EditMessage m newContent)
      show "procedureCorrect progr S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre EditMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
              metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct progr S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound3)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: EditMessage procedures_def )

          show "localState S i \<triangleq> editMessage_impl (MessageId m) (String newContent)"
            by (auto simp add: EditMessage procedures_def )

          show "invocationOp S i \<triangleq> EditMessage m newContent"
            using EditMessage \<open>invocationOp S i \<triangleq> proc\<close> by blast

          note editMessage_impl_def[simp]

          

          show "execution_s_check progr i s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds (s_invocationOp(i \<mapsto> EditMessage m newContent)) (s_invocationRes(i := None)) {} {} {} [] None True (editMessage_impl (MessageId m) (String newContent))"
            if tx_fresh: "(\<And>tx. s_transactionOrigin tx \<noteq> Some i)"
            for  s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds s_invocationOp s_invocationRes
          proof (repliss_vcg, goal_cases "Exists_AtCommit" "Exists_AtReturn" "NotExists_AtCommit" "NotExists_AtReturn")
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa)

            note `c \<noteq> ca`[simp]

            from `example_chat.inv
             \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin', transactionOrigin = s_transactionOrigin',
                knownIds = s_knownIds', invocationOp = s_invocationOp'(i \<mapsto> EditMessage m newContent),
                invocationRes = s_invocationRes'(i := None)\<rparr>`
            have  i1: "inv1 (s_invocationOp'(i \<mapsto> EditMessage m newContent)) (s_invocationRes'(i := None))"
              and i2: "inv2 (s_invocationOp'(i \<mapsto> EditMessage m newContent)) s_calls'"
              and i3: "inv3 s_calls' s_happensBefore'"
              and i4: "inv4 s_calls' s_happensBefore'"
              by (auto simp add: inv_def)

            from \<open>crdtSpec (Message (KeyExists (MessageId m))) \<lparr>calls = s_calls' |` vis', happensBefore = s_happensBefore' |r vis'\<rparr> (Bool True)\<close>
            obtain upd_c upd_op upd_r
              where upd_vis: "upd_c \<in> vis'"
                and upd_call: "s_calls' upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
                and upd_is_update: "is_update upd_op"
                and ipd_not_deleted: "\<forall>c'. c' \<in> vis' \<longrightarrow> (\<forall>x2. s_calls' c' \<triangleq> x2 \<longrightarrow> (\<forall>x2a. x2 \<noteq> Call (Message (DeleteKey (MessageId m))) x2a) \<or> (c', upd_c) \<in> s_happensBefore')"
              by (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def restrict_ctxt_op_def restrict_ctxt_def fmap_map_values_def'
                      restrict_map_def deleted_calls_dw_def restrict_relation_def
                   split: option.splits if_splits operation.splits call.splits)





            hence "upd_r = Undef"
              using Exists_AtCommit(9) query_result_undef by auto


            have "upd_c \<noteq> c"
              by (smt Exists_AtCommit(15) Exists_AtCommit(5) Exists_AtCommit(9) basic_trans_rules(31) domIff invariantContext.simps(1) operationContext.select_convs(1) upd_vis wellFormed_callOrigin_dom3)

            have "upd_c \<noteq> ca"
              by (smt Exists_AtCommit(15) Exists_AtCommit(5) Exists_AtCommit(9) basic_trans_rules(31) domIff invariantContext.simps(1) operationContext.select_convs(1) upd_vis wellFormed_callOrigin_dom)

            obtain upda_c upda_val
              where upda_call: "s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef"
                and upda_before_upd: "(upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c"
            proof (atomize_elim, cases upd_op)
              case (Author a)
              obtain x where "a = Assign x"
                using upd_is_update Author 
                by (cases a, auto simp add: is_update_messageDataOp_def)

              show "\<exists>upda_c upda_val.
                   s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                   ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                using Author \<open>a = Assign x\<close> upd_call \<open>upd_r = Undef\<close> by blast

            next
              case (Content a)
              obtain x where "a = Assign x"
                using upd_is_update Content 
                by (cases a, auto simp add: is_update_messageDataOp_def)

              show "\<exists>upda_c upda_val.
                 s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                 ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                using i3 Content \<open>a = Assign x\<close> \<open>upd_r = Undef\<close> upd_call 
                by (auto simp add: inv3_def, blast)
            qed



            have "upda_c \<noteq> c"
              using Exists_AtCommit(16) \<open>upd_c \<noteq> c\<close> upda_before_upd by blast

            have "upda_c \<noteq> ca"
              using Exists_AtCommit(16) \<open>upd_c \<noteq> ca\<close> upda_before_upd by blast





            from Exists_AtCommit
            show ?case
            proof (auto simp add: inv_def, goal_cases "inv2" "inv3" "inv4" )
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              show ?case 
                apply (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong)
                 apply (rule_tac x=upda_c in exI)
                 apply (auto simp add: \<open>upda_c \<noteq> c\<close> \<open>upda_c \<noteq> ca\<close> upda_call)
                using causallyConsistent_def inv3(6) upd_vis upda_before_upd apply fastforce
                by (metis i3 inv3(12) inv3_def)
            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                apply (auto simp add: inv4_def updateHb_cases in_sequence_cons)
                by (metis (no_types, lifting) \<open>upd_r = Undef\<close> ipd_not_deleted upd_call upd_is_update)
            qed
              
          next
            case (Exists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa)
            then show ?case 
              apply (auto simp add: inv_def )
              apply (auto simp add: inv1_def cong: conj_cong)
              by (smt map_upd_Some_unfold proc.distinct(1))
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case 
            proof (auto simp add: inv_def, goal_cases inv2 inv3 inv4)
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case by (auto simp add: inv2_def)
            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case by (auto simp add: inv3_def updateHb_single cong: conj_cong, fastforce)
            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv4_def updateHb_single)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case 
              apply (auto simp add: inv_def inv1_def cong: conj_cong)
              by (meson option.inject proc.simps(6))
          qed
        qed
      qed
    next
      case (DeleteMessage m)


      show "procedureCorrect progr S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre DeleteMessage show_P.i_fresh
          by (auto simp add:  inv_def inv1_def inv2_def inv3_def inv4_def invContextH2_simps, 
              metis option.distinct(1) show_P.i_fresh)+

      next
        case execution

        show "execution_s_correct progr S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound3)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: DeleteMessage procedures_def )

          show "localState S i \<triangleq> deleteMessage_impl (MessageId m)"
            by (auto simp add: DeleteMessage procedures_def )

          show "invocationOp S i \<triangleq> DeleteMessage m"
            using DeleteMessage \<open>invocationOp S i \<triangleq> proc\<close> by blast

          note deleteMessage_impl_def[simp]

          show "execution_s_check progr i s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds (s_invocationOp(i \<mapsto> DeleteMessage m)) (s_invocationRes(i := None)) {} {} {} [] None True (deleteMessage_impl (MessageId m))"
            if tx_fresh: "(\<And>tx. s_transactionOrigin tx \<noteq> Some i)"
            for  s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds s_invocationOp s_invocationRes
          proof (repliss_vcg, goal_cases "Exists_AtCommit" "Exists_AtReturn" "NotExists_AtCommit" "NotExists_AtReturn")
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)

            from `c \<noteq> ca \<and> c \<noteq> cb \<and> ca \<noteq> cb`
            have [simp]: "c \<noteq> ca" "c \<noteq> cb" "ca \<noteq> cb"
              by auto


            from `example_chat.inv
               \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin', transactionOrigin = s_transactionOrigin',
                  knownIds = s_knownIds', invocationOp = s_invocationOp'(i \<mapsto> DeleteMessage m), invocationRes = s_invocationRes'(i := None)\<rparr>`
            have  i1: "inv1 (s_invocationOp'(i \<mapsto> DeleteMessage m)) (s_invocationRes'(i := None))"
              and i2: "inv2 (s_invocationOp'(i \<mapsto> DeleteMessage m)) s_calls'"
              and i3: "inv3 s_calls' s_happensBefore'"
              and i4: "inv4 s_calls' s_happensBefore'"
              by (auto simp add: inv_def)

            show ?case
            proof (auto simp add: inv_def, goal_cases inv1 inv2 inv3 inv4)
              case inv1
              from i1
              show ?case by auto
            next
              case inv2
              from i2
              show ?case
                by (auto simp add: inv2_def)
            next
              case inv3
              from i3
              show ?case 
                apply (auto simp add: inv3_def updateHb_cases cong: conj_cong)
                by (metis Exists_AtCommit(17)) 

            next
              case inv4
              then show ?case
                apply (auto simp add: inv4_def updateHb_cases in_sequence_cons)
                using Exists_AtCommit(17) apply blast
                by (meson i4 inv4_def)
            qed
              
          next
            case (Exists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)
            then show ?case
              apply (auto simp add: inv_def inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(3))
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case
            proof (auto simp add: inv_def, goal_cases inv2 inv3 inv4)
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case
                by (auto simp add: inv2_def)
            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons, fastforce)

            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cases in_sequence_cons)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case 
              apply (auto simp add: inv_def inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(3)) 
          qed
        qed
      qed
    next
      case (GetMessage m)


      show "procedureCorrect progr S i"
      proof M_show_procedureCorrect
        case after_invocation
        show ?case
          using show_P.invariant_pre GetMessage show_P.i_fresh
        proof (auto simp add:  inv_def invContextH2_simps, goal_cases inv1 inv2)
          case inv1
          then show ?case
            apply (auto simp add: inv1_def state_wellFormed_invocation_before_result)
            by (metis option.simps(3) show_P.i_fresh)
        next
          case inv2
          then show ?case
            apply (auto simp add: inv2_def)
            by (metis option.distinct(1) show_P.i_fresh)
        qed

      next
        case execution

        show "execution_s_correct progr S i"
          using procedure_correct.in_initial_state
        proof (fuzzy_rule execution_s_check_sound3)
          show "currentProc S i \<triangleq> toImpl"
            by (auto simp add: GetMessage procedures_def )

          show "localState S i \<triangleq> getMessage_impl (MessageId m)"
            by (auto simp add: GetMessage procedures_def )

          show "invocationOp S i \<triangleq> GetMessage m"
            using GetMessage \<open>invocationOp S i \<triangleq> proc\<close> by blast

          note getMessage_impl_def[simp]

          show "execution_s_check progr i s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds (s_invocationOp(i \<mapsto> GetMessage m)) (s_invocationRes(i := None)) {} {} {} [] None True (getMessage_impl (MessageId m))"
            if tx_fresh: "(\<And>tx. s_transactionOrigin tx \<noteq> Some i)"
            for  s_calls s_happensBefore s_callOrigin s_transactionOrigin s_knownIds s_invocationOp s_invocationRes
          proof (repliss_vcg, goal_cases "Exists_AtCommit" "Exists_AtReturn" "NotExists_AtCommit" "NotExists_AtReturn")
            case (Exists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)
            then show ?case 
            proof (auto simp add: inv_def, goal_cases inv2 inv3 inv4)
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv3_def  updateHb_cons cong: conj_cong, meson)
            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cons is_update_messageDataOp_def)
            qed  
          next
            case (Exists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res ca resa cb resb)
            
            from \<open>example_chat.inv
             \<lparr>calls = s_calls', happensBefore = s_happensBefore', callOrigin = s_callOrigin',
                transactionOrigin = s_transactionOrigin', knownIds = s_knownIds',
                invocationOp = s_invocationOp'(i \<mapsto> GetMessage m), invocationRes = s_invocationRes'(i := None)\<rparr>\<close>
            have i1: "inv1 (s_invocationOp'(i \<mapsto> GetMessage m)) (s_invocationRes'(i := None))"
              and i2: "inv2 (s_invocationOp'(i \<mapsto> GetMessage m)) s_calls'"
              and i3: "inv3 s_calls' s_happensBefore'"
              and i4: "inv4 s_calls' s_happensBefore'"
              by (auto simp add: inv_def)
            
            from Exists_AtReturn show ?case
            proof (auto simp add: inv_def, goal_cases inv1)
              case (inv1 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)

              

              show ?case
              proof (auto simp add: inv1_def cong: conj_cong)

                show "\<exists>s. s \<noteq> i \<and> (\<exists>content2. s_invocationOp' s \<triangleq> SendMessage author content2)"
                  if c0: "g \<noteq> i"
                    and c1: "s_invocationOp' g \<triangleq> GetMessage m'"
                    and c2: "s_invocationRes' g \<triangleq> Found (String author) content"
                  for  g m' author content
                  using \<open>inv1 (s_invocationOp'(i \<mapsto> GetMessage m)) (s_invocationRes'(i := None))\<close>
                  using that apply (auto simp add: inv1_def)
                  by (metis option.inject proc.distinct(5))


                show "\<exists>s. s \<noteq> i \<and> (\<exists>content2. s_invocationOp' s \<triangleq> SendMessage author content2)"
                  if c0: "resa = String author"
                  for  author
                proof -

                  have [simp]: "x \<in> Field (s_happensBefore' |r vis') \<Longrightarrow> x \<in> vis'" for x
                    by (auto simp add: Field_def restrict_relation_def)

                  hence [simp]: " x \<in> Field (s_happensBefore' |r vis') \<Longrightarrow> \<exists>y. s_calls' x \<triangleq> y" for x
                    by (meson  in_dom `vis' \<subseteq> dom s_calls'`)

                  from \<open>crdtSpec (Message (KeyExists (MessageId m)))
                     \<lparr>calls = s_calls' |` vis', happensBefore = s_happensBefore' |r vis'\<rparr> (Bool True)\<close>
                  have "crdtSpec' (Message (KeyExists (MessageId m))) (dom s_calls' \<inter> vis') (extract_op s_calls') s_happensBefore' id (Bool True)"
                    apply (subst(asm) crdtSpec'_alt)
                    by (auto simp add: crdtSpec'_alt crdtSpec'_simp_op crdtSpec'_simp_hb)



                  from this
                  obtain upd_c upd_call upd_op
                    where upd_call1: "s_calls' upd_c \<triangleq> upd_call"
                      and upd_vis: "upd_c \<in> vis'"
                      and upd_c_op: "extract_op s_calls' upd_c = Message (NestedOp (MessageId m) upd_op)"
                      and upd_is_update: "is_update upd_op"
                      and ud_not_deleted: "\<forall>d. extract_op s_calls' d = Message (DeleteKey (MessageId m)) \<longrightarrow> d \<in> dom s_calls' \<and> d \<in> vis' \<longrightarrow> (d, upd_c) \<in> s_happensBefore'"
                    by (auto simp add: C_out_calls_def crdtSpec'_def struct_field'_def map_dw_spec'_def map_spec'_def deleted_calls_dw'_def)

                  obtain upd_r where 
                    upd_call: "s_calls' upd_c \<triangleq> Call (Message (NestedOp (MessageId m) upd_op)) upd_r"
                    using upd_call1 upd_c_op
                    by (auto simp add: extract_op_def split: call.splits)


                  have "upd_r = Undef"
                    using local.Exists_AtReturn(9) upd_call upd_is_update
                    by (rule query_result_undef)


                  obtain upda_c upda_val
                    where upda_call: "s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef"
                      and upda_before_upd: "(upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c"
                  proof (atomize_elim, cases upd_op)
                    case (Author a)
                    obtain x where "a = Assign x"
                      using upd_is_update Author 
                      by (cases a, auto simp add: is_update_messageDataOp_def)

                    show "\<exists>upda_c upda_val.
                   s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                   ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                      using Author \<open>a = Assign x\<close> upd_call \<open>upd_r = Undef\<close> by blast

                  next
                    case (Content a)
                    obtain x where "a = Assign x"
                      using upd_is_update Content 
                      by (cases a, auto simp add: is_update_messageDataOp_def)

                    show "\<exists>upda_c upda_val.
                 s_calls' upda_c \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign upda_val)))) Undef \<and>
                 ((upda_c, upd_c) \<in> s_happensBefore' \<or> upda_c = upd_c)"
                      using i3 Content \<open>a = Assign x\<close> \<open>upd_r = Undef\<close> upd_call 
                      by (auto simp add: inv3_def, blast)
                  qed

                  have [simp]: "upda_c \<noteq> c"
                    by (metis Exists_AtReturn(9) inv1(12) invariantContext.simps(1) operationContext.simps(1) option.simps(3) upda_call wellFormed_callOrigin_dom3)


                  from \<open>crdtSpec (Message (NestedOp (MessageId m) (Author Read)))
                   \<lparr>calls = (s_calls' |` (vis' - {c}))(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True)),
                      happensBefore = updateHb (s_happensBefore' |r vis') vis' [c]\<rparr>
                   resa\<close>
                  have spec1: "crdtSpec' (Message (NestedOp (MessageId m) (Author Read))) (insert c (dom s_calls' \<inter> (vis' - {c})))
                       (extract_op ((s_calls' |` (vis' - {c}))(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True))))
                       (updateHb (s_happensBefore' |r vis') vis' [c]) id resa"
                    apply (subst(asm) crdtSpec'_alt)
                  proof (auto simp add: crdtSpec'_alt crdtSpec'_simp_op crdtSpec'_simp_hb  )

                    show "\<exists>y. s_calls' x \<triangleq> y"
                      if c0: "x \<in> Field (updateHb (s_happensBefore' |r vis') vis' [c])"
                        and c1: "x \<noteq> c"
                      for  x
                      using that `vis' \<subseteq> dom s_calls'` by (auto simp add: in_sequence_cons Field_def restrict_relation_def updateHb_cases)


                    show "x \<in> vis'"
                      if c0: "x \<in> Field (updateHb (s_happensBefore' |r vis') vis' [c])"
                        and c1: "x \<noteq> c"
                      for  x
                      using that `vis' \<subseteq> dom s_calls'` by (auto simp add: in_sequence_cons Field_def restrict_relation_def updateHb_cases)
                  qed

                  have spec2: "crdtSpec' (Message (NestedOp (MessageId m) (Author Read))) 
                       (insert c (dom s_calls' \<inter> (vis' - {c})))
                       ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                       (updateHb s_happensBefore' vis' [c]) id resa"
                    thm use_ccrdtSpec_wf1[OF crdtSpec'_wf ]
                  proof (rule use_ccrdtSpec_wf1[OF crdtSpec'_wf, rotated -1, OF spec1])

                    show " map_same_on (insert c (dom s_calls' \<inter> (vis' - {c})))
                       (extract_op ((s_calls' |` (vis' - {c}))(c \<mapsto> Call (Message (KeyExists (MessageId m))) (Bool True))))
                       ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))"
                      by (auto simp add: map_same_on_def extract_op_def)

                    show " rel_same_on (insert c (dom s_calls' \<inter> (vis' - {c}))) (updateHb (s_happensBefore' |r vis') vis' [c])
                           (updateHb s_happensBefore' vis' [c])"
                      using inv1(13) by (auto simp add: rel_same_on_def updateHb_cons restrict_relation_def)
                  qed

                  have [simp]: "(\<lambda>x. Message (NestedOp (MessageId m) x)) \<circ> Author
                      = Message \<circ> (NestedOp (MessageId m)) \<circ> Author"
                    by auto

                  have [simp]: "upda_c \<in> vis'"
                    using causallyConsistent_def inv1(6) upd_vis upda_before_upd by fastforce

                  from spec2
                  have "is_from (String author) Undef
                     (latest_values'
                       (C_out_calls (Message \<circ> NestedOp (MessageId m) \<circ> Author)
                         ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                         (C_out_calls (Message \<circ> NestedOp (MessageId m)) ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                           (insert c (dom s_calls' \<inter> (vis' - {c}))) -
                          deleted_calls_dw'
                           (C_out_calls Message ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                             (insert c (dom s_calls' \<inter> (vis' - {c}))))
                           ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (updateHb s_happensBefore' vis' [c]) Message
                           (MessageId m)))
                       ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (updateHb s_happensBefore' vis' [c])
                       (Message \<circ> NestedOp (MessageId m) \<circ> Author))"
                    by (auto simp add: crdtSpec'_def `resa = String author` struct_field'_def map_dw_spec'_def
                        map_spec'_def restrict_calls_def2 messageStruct'_def register_spec'_def)

                  hence "(String author) \<in>
                     (latest_values'
                       (C_out_calls (Message \<circ> NestedOp (MessageId m) \<circ> Author)
                         ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                         (C_out_calls (Message \<circ> NestedOp (MessageId m)) ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                           (insert c (dom s_calls' \<inter> (vis' - {c}))) -
                          deleted_calls_dw'
                           (C_out_calls Message ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                             (insert c (dom s_calls' \<inter> (vis' - {c}))))
                           ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (updateHb s_happensBefore' vis' [c]) Message
                           (MessageId m)))
                       ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (updateHb s_happensBefore' vis' [c])
                       (Message \<circ> NestedOp (MessageId m) \<circ> Author))"
                    apply (rule is_from_exists[THEN iffD1, rotated])
                  proof (rule latest_values'_exists)

                    show "finite
                       (C_out_calls (Message \<circ> NestedOp (MessageId m) \<circ> Author) ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                         (C_out_calls (Message \<circ> NestedOp (MessageId m)) ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                           (insert c (dom s_calls' \<inter> (vis' - {c}))) -
                          deleted_calls_dw'
                           (C_out_calls Message ((extract_op s_calls')(c := Message (KeyExists (MessageId m))))
                             (insert c (dom s_calls' \<inter> (vis' - {c}))))
                           ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (updateHb s_happensBefore' vis' [c]) Message
                           (MessageId m)))"
                      sorry

                    have "acyclic s_happensBefore'"
                      using happensBefore_acyclic[OF local.inv1(16)] by simp
                      find_theorems state_wellFormed s_happensBefore'

                    show "acyclic (updateHb s_happensBefore' vis' [c])"
                      apply (auto simp add: updateHb_cons)
                      find_theorems acyclic "(\<union>)"

                    apply (rule_tac x=upda_val in exI)
                    apply (auto simp add: latest_values'_def latest_assignments'_def deleted_calls_dw'_def
                        image_iff cong: conj_cong)
                    apply (rule_tac x=upda_c in exI)
                    apply auto
                      apply (auto simp add: in_C_out upda_call extract_op_def updateHb_cons split: call.splits option.splits)
                  proof -

                    from upda_before_upd
                    show "(d, upda_c) \<in> s_happensBefore'"
                      if d_not_c: "d \<noteq> c"
                        and d_vis: "d \<in> vis'"
                        and d_call: "s_calls' d \<triangleq> Call (Message (DeleteKey (MessageId m))) x2"
                      for  d x2
                    proof 


                      obtain d_ctxt where "querySpec progr (Message (DeleteKey (MessageId m))) d_ctxt x2"
                        using Exists_AtReturn(9) d_call get_query_spec by blast

                      hence [simp]: "x2 = Undef"
                        by (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def) 

                      have [simp]: "d \<in> dom s_calls'"
                        using d_call by blast

                      have "(d, upd_c) \<in> s_happensBefore'"
                        using ud_not_deleted[rule_format, where d=d]  d_vis d_call
                        by (auto simp add: extract_op_def split: option.splits)

                      show "(d, upda_c) \<in> s_happensBefore'" if "upda_c = upd_c"
                        using `(d, upd_c) \<in> s_happensBefore'` `upda_c = upd_c` by simp


                      show "(d, upda_c) \<in> s_happensBefore'"
                        if c0: "(upda_c, upd_c) \<in> s_happensBefore'"
                      proof (rule ccontr)
                        assume "(d, upda_c) \<notin> s_happensBefore'"

                        from `inv4 s_calls' s_happensBefore'`
                        show False
                          apply (auto simp add: inv4_def)
                          apply (drule spec[where x=upd_c])
                          apply (drule spec[where x=d])
                          using upd_is_update by (auto simp add: d_call upd_call  \<open>upd_r = Undef\<close> \<open>(d, upd_c) \<in> s_happensBefore'\<close>)
                      qed
                    qed

                    show "False"
                      if c0: "c' \<noteq> c"
                        and c1: "c' \<in> vis'"
                        and c2: "(upda_c, c') \<in> s_happensBefore'"
                        and c3: "\<forall>d\<in>C_out_calls Message ((extract_op s_calls')(c := Message (KeyExists (MessageId m)))) (insert c (dom s_calls' \<inter> (vis' - {c}))). ((\<exists>y. s_calls' d \<triangleq> y) \<or> d = c \<or> d \<noteq> c \<and> (??? = Message (DeleteKey (MessageId m)) \<longrightarrow> (d, c') \<in> s_happensBefore')) \<and> (\<forall>x2. s_calls' d \<triangleq> x2 \<longrightarrow> (\<forall>x1. (\<forall>x2a. x2 \<noteq> Call x1 x2a) \<or> d = c \<or> d \<noteq> c \<and> (x1 = Message (DeleteKey (MessageId m)) \<longrightarrow> (d, c') \<in> s_happensBefore')))"
                        and c4: "s_calls' c' \<triangleq> Call (Message (NestedOp (MessageId m) (Author (Assign v')))) x2a"
                      for  c' v' x2a



                  qed

                    hence ???
                      apply (auto simp add:)

               (*     apply (auto simp add: crdtSpec_def struct_field_def map_dw_spec_def map_spec_def restrict_ctxt_op_def restrict_ctxt_def fmap_map_values_def
                      restrict_map_def deleted_calls_dw_def restrict_relation_def updateHb_cons
                      messageStruct_def register_spec_def ctxt_remove_calls_def
                      split: option.splits if_splits operation.splits call.splits
                      cong: disj_cong conj_cong)
*)


                  sorry
              qed

            qed
          next
            case (NotExists_AtCommit tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case
            proof (auto simp add: inv_def, goal_cases inv2 inv3 inv4)
              case (inv2 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv2_def)
            next
              case (inv3 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv3_def updateHb_cases in_sequence_cons cong: conj_cong, fastforce)
            next
              case (inv4 some_generatedIds some_generatedIds1 some_currentTransaction some_currentTransaction1 some_localState some_localState1 some_currentProc some_currentProc1 some_visibleCalls some_visibleCalls1 some_transactionStatus some_transactionStatus1 some_generatedIds2 some_currentTransaction2 some_localState2 some_currentProc2 some_visibleCalls2 some_transactionStatus2)
              then show ?case 
                by (auto simp add: inv4_def updateHb_cases in_sequence_cons)
            qed
          next
            case (NotExists_AtReturn tx s_calls' s_happensBefore' s_callOrigin' s_transactionOrigin' s_knownIds' vis' s_invocationOp' s_invocationRes' c res)
            then show ?case
              apply (auto simp add: inv_def)
              apply (auto simp add: inv1_def)
              by (metis (no_types, lifting) option.inject proc.distinct(5))
          qed
        qed
      qed
    qed
  qed
qed


end
